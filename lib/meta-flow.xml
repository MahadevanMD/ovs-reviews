<?xml version="1.0" encoding="utf-8"?>
<fields>
  <h1>Introduction</h1>

  <p>
    This document aims to comprehensively document all of the fields,
    both standard and non-standard, supported by OpenFlow or Open
    vSwitch, regardless of origin.
  </p>

  <h2>Fields</h2>

  <p>
    A <dfn>field</dfn> is a property of a packet.  Most familiarly,
    <dfn>data fields</dfn> are fields that can be extracted from a
    packet.  Most are copied directly from protocol headers, e.g. at
    layer 2, the Ethernet source and destination addresses, or the
    VLAN ID; at layer 3, the IPv4 or IPv6 source and destination; and
    at layer 4, the TCP or UDP ports.  Other data fields are computed,
    e.g. <ref field="MFF_IP_FRAG"/> describes whether a packet is a
    fragment but it is not copied directly from the IP header.
  </p>

  <p>
    Some data fields, called <dfn>root fields</dfn>, are always present
    as a consequence of the basic networking technology in use.
    Ethernet is the assumed base technology for current versions of
    OpenFlow and Open vSwitch, so Ethernet header fields are always
    available.
    <!-- future directions: EXT-112 -->
  </p>

  <p>
    Other data fields are not always present.  A packet contains ARP
    fields, for example, only when its Ethernet header indicates the
    Ethertype for ARP, 0x0806.  We say that a field is
    <dfn>applicable</dfn> when it is it present in a packet, and
    <dfn>inapplicable</dfn> when it is not, and refer to the
    conditions that determine whether a field is applicable as
    <dfn>prerequisites</dfn>.  Some VLAN-related fields are a special
    case: these fields are always applicable, but have a designated
    value or bit that indicates whether a VLAN header is present, with
    the remaining values or bits indicating the VLAN header's content
    (if it is present).  <!-- XXX also ethertype -->
  </p>

  <p>
    An inapplicable field does not have a value, not even a nominal
    ``value'' such as all-zero-bits.  In many circumstances, OpenFlow
    and Open vSwitch allow references only to applicable fields.  For
    example, one may match (see <cite>Matching</cite>, below) a given
    field only if the match includes the field's prerequisite,
    e.g. matching an ARP field is only allowed if one also matches on
    Ethertype 0x0806.
  </p>

  <p>
    Sometimes a packet may contain multiple instances of a header.
    For example, a packet may contain multiple VLAN or MPLS headers,
    and tunnels can cause any data field to recur.  OpenFlow and Open
    vSwitch do not address these cases uniformly.  For VLAN and MPLS
    headers, only the outermost header is accessible, so that inner
    headers may be accessed only by ``popping'' (removing) the outer
    header.  (Open vSwitch supports only a single VLAN header in any
    case.)  For tunnels, e.g. GRE or VXLAN, the outer header and inner
    headers are treated as different data fields.
  </p>

  <p>
    Many network protocols are built in layers as a stack of
    concatenated headers.  Each header typically contains a ``next
    type'' field that indicates the type of the protocol header that
    follows, e.g. Ethernet contains an Ethertype and IPv4 contains a
    IP protocol type.  The exceptional cases, where protocols are
    layered but an outer layer does not indicate the protocol type for
    the inner layer, or gives only an ambiguous indication, are
    troublesome.  An MPLS header, for example, only indicates whether
    another MPLS header or some other protocol follows, and in the
    latter case the inner protocol must be known from the context.  In
    these exceptional cases, OpenFlow and Open vSwitch cannot provide
    insight into the inner protocol data fields without additional
    context.  In the case of MPLS, the OpenFlow ``pop MPLS'' action
    that removes the last MPLS header from a packet provides this
    context, as the Ethertype of the payload.  See <cite>Layer 2.5:
    MPLS</cite> for more information.
  </p>

  <p>
    OpenFlow and Open vSwitch support some fields other than data
    fields.  <dfn>Metadata fields</dfn> relate to the origin or
    treatment of a packet, but they are not extracted from the packet
    data itself.  One example is the physical port on which a packet
    arrived at the switch.  <dfn>Register fields</dfn> act like
    variables: they give an OpenFlow switch space for temporary
    storage while processing a packet.  Existing metadata and register
    fields have no prerequisites.
  </p>

  <p>
    A field's value consists of an integral number of bytes.  For data
    fields, sometimes those bytes are taken directly from the packet.
    Other data fields are copied from a packet with padding (usually
    with zeros and in the most significant positions).  The remaining
    data fields are transformed in other ways as they are copied from
    the packets, to make them more useful for matching.
  </p>

  <h2>Matching</h2>

  <p>
    The most important use of fields in OpenFlow is
    <dfn>matching</dfn>, to determine whether particular field values
    agree with a set of constraints called a <dfn>match</dfn>.  A
    match consists of zero or more constraints on individual fields,
    all of which must be met to satisfy the match.  (A match that
    contain no constraints is always satisfied.)  OpenFlow and Open
    vSwitch support a number of forms of matching on individual
    fields:
  </p>

  <dl>
    <dt><dfn>Exact match</dfn>, e.g. ``<var>ip_src</var> = 10.1.2.3''</dt>
    <dd>
      <p>
	Only a particular value of the field is matched; for example,
	only one particular source IP address.
      </p>

      <p>
	All fields support exact matches.
      </p>
    </dd>

    <dt>
      <dfn>Bitwise match</dfn>, e.g. ``<var>ip_src</var> in 10.1.0.0/16''
    </dt>
    <dd>
      <p>
	Specific bits in the field must have specified values; for
	example, only source IP addresses in a particular subnet.
      </p>

      <p>
	Support for bitwise matches varies depending on the switch
	implementation and the field.  Some fields support
	<dfn>arbitrary bitwise match</dfn> that match any subset of
	bits.  Other fields more restricted forms, such as matching
	contiguous sets of bits starting from the most significant
	bit, i.e. only ``CIDR'' masks [RFC 4632].
      </p>
    </dd>

    <dt><dfn>Wildcard</dfn>, e.g. ``any <var>ip_src</var>''</dt>
    <dd>
      <p>
	The value of the field is not constrained.
      </p>

      <p>
	There is a tiny difference between wildcarding a field and not
	specifying any match on a field: wildcarding a field requires
	satisfying the field's prerequisites.
      </p>
    </dd>
  </dl>

  <p>
    Some types of matches cannot be expressed directly with OpenFlow
    and Open vSwitch.  These can be expressed indirectly:
  </p>

  <dl>
    <dt><dfn>Set match</dfn>, e.g. ``<var>tcp_dst</var> ∈ {80, 443,
    8080}''</dt>
    <dd>
      <p>
	The value of a field is one of a specified set of values; for
	example, the TCP destination port is 80, 443, or 8080.
      </p>

      <p>
	For matches used in flows (see <cite>Flows</cite>, below), multiple
	flows can simulate set matches.
      </p>
    </dd>

    <dt><dfn>Range match</dfn>, e.g. ``1000 ≤ <var>tcp_dst</var> ≤
    1999''</dt>
    <dd>
      <p>
	The value of the field must lie within a numerical range, for
	example, TCP destination ports between 1000 and 1999.
      </p>

      <p>
	Range matches can be expressed as a collection of bitwise
	matches.  See <ref field="OXM_OF_TCP_DST"/> for an example.
      </p>
    </dd>

    <dt><dfn>Inequality match</dfn>, e.g. ``<var>tcp_dst</var> ≠ 80''</dt>
    <dd>
      <p>
	The value of the field differs from a specified value, for
	example, all TCP destination ports except 80.
      </p>

      <p>
	Inequality matches can be expressed as a pair of range
	matches, e.g. ``not port 80'' as ``port 0 to 79 or port 81 to
	65535,'' which can in turn be expressed as collections of
	bitwise matches (see <cite>Range match</cite> above).  For matches
	used in flows (see <cite>Flows</cite>, below), sometimes one can
	more compactly express inequality as a higher-priority flow
	that matches the exceptional case paired with a lower-priority
	flow that matches the general case.
      </p>
    </dd>
  </dl>

  <p>
    All of the supported forms of matching are special cases of
    bitwise matching.  In some cases this influences the design of
    field values.  <ref field="MFF_IP_FRAG"/> is the most prominent
    example: it is designed to make all of the practically useful
    checks for IP fragmentation possible as a single bitwise match.
  </p>

  <h2>Evolution of OpenFlow Fields</h2>

  <p>
    The discussion so far applies to all OpenFlow and Open vSwitch
    versions.  This section starts to draw in specific information by
    explaining, in broad terms, the treatment of fields and matches in
    each OpenFlow version.
  </p>

  <h3>OpenFlow 1.0</h3>

  <p>
    OpenFlow 1.0 defined the OpenFlow protocol format of a match as a
    fixed-length data structure that could match on the following
    fields:
  </p>

  <ul>
    <li>Ingress port.</li>
    <li>Ethernet source and destination MAC.</li>
    <li>Ethertype (with a special value to match frames that lack an
    Ethertype).</li>
    <li>VLAN ID and priority.</li>
    <li>IPv4 source, destination, protocol, and DSCP.</li>
    <li>TCP source and destination port.</li>
    <li>UDP source and destination port.</li>
    <li>ICMPv4 type and code.</li>
    <li>ARP IPv4 addresses (SPA and TPA) and opcode.</li>
  </ul>

  <p>
    Each supported field corresponded to some member of the data
    structure.  Some members represented multiple fields, in the case
    of the TCP, UDP, ICMPv4, and ARP fields whose presence is mutually
    exclusive.  This also meant that some members were poor fits for
    their fields: only the low 8 bits of the 16-bit ARP opcode could
    be represented, and the ICMPv4 type and code were padded with 8 bits
    of zeros to fit in the 16-bit members primarily meant for TCP and
    UDP ports.  An additional bitmap member indicated, for each
    member, whether its field should be an ``exact'' or ``wildcarded''
    match (see <cite>Matching</cite>), with additional support for
    CIDR prefix matching on the IPv4 source and destination fields.
  </p>

  <p>
    Simplicity was recognized early on as the main virtue of this
    approach.  Obviously, any fixed-length data structure cannot
    support matching new protocols that do not fit.  There was no
    room, for example, for matching IPv6 fields, which was not a
    priority at the time.  Lack of room to support matching the
    Ethernet addresses inside ARP packets actually caused more of a
    design problem later, leading to an Open vSwitch extension action
    specialized for dropping ``spoofed'' ARP packets in which the
    frame and ARP Ethernet source addressed differed.  (This extension
    was never standardized.  Open vSwitch dropped support for it a few
    releases after it added support for full ARP matching.)
  </p>

  <p>
    The design of the OpenFlow fixed-length matches also illustrates
    compromises, in both directions, between the strengths and
    weaknesses of software and hardware that have always influenced
    the design of OpenFlow.  Support for matching ARP fields that do
    fit in the data structure was only added late in the design
    process (and remained optional in OpenFlow 1.0), for example,
    because common switch ASICs did not support matching these fields.
  </p>

  <p>
    The compromises in favor of software occurred for more complicated
    reasons.  The OpenFlow designers did not know how to implement
    matching in software that was fast, dynamic, and general.  (A way
    was later found [Srinivasan].)  Thus, the designers sought to
    support dynamic, general matching that would be fast in realistic
    special cases, in particular when all of the matches were
    <dfn>microflows</dfn>, that is, matches that specify every field
    present in a packet, because such matches can be implemented as a
    single hash table lookup.  Contemporary research supported the
    feasibility of this approach: the number of microflows in a campus
    network had been measured to peak at about 10,000 [Casado, section
    3.2].  (Calculations show that this can only be true in a lightly
    loaded network [Pepelnjak].)
  </p>

  <p>
    As a result, OpenFlow 1.0 required switches to treat microflow
    matches as the highest possible priority.  This let software
    switches perform the microflow hash table lookup first. Only on
    failure to match a microflow did the switch need to fall back to
    checking the more general and presumed slower matches.  Also, the
    OpenFlow 1.0 flow match was minimally flexible, with no support
    for general bitwise matching, partly on the basis that this seemed
    more likely amenable to relatively efficient software
    implementation. (CIDR masking for IPv4 addresses was added
    relatively late in the OpenFlow 1.0 design process.)
  </p>

  <p>
    Microflow matching was later discovered to aid some hardware
    implementations.  The TCAM chips used for matching in hardware do
    not support priority in the same way as OpenFlow but instead tie
    priority to ordering [Pagiamtzis].  Thus, adding a new match with
    a priority in the middle of existing matches can require
    reordering an arbitrary number of TCAM entries.  On the other
    hand, when microflows are highest priority, they can be managed as
    a set-aside portion of the TCAM entries.
  </p>

  <p>
    The emphasis on matching microflows also led designers to
    carefully consider the bandwidth requirements between switch and
    controller: to maximize the number of microflow setups per second,
    one must minimize the size of each flow's description.  This
    favored the fixed-length format in use, because it expressed
    common TCP and UDP microflows in fewer bytes than more flexible
    ``type-length-value'' (TLV) formats.  (Early versions of OpenFlow
    also avoided TLVs in general to head off protocol fragmentation.)
  </p>

  <h4>Inapplicable Fields</h4>

  <p>
    OpenFlow 1.0 does not clearly specify how to treat inapplicable
    fields.  The members for inapplicable fields are always present in
    the match data structure, as are the bits that indicate whether
    the fields are matched, and the ``correct'' member and bit values
    for inapplicable fields is unclear.  OpenFlow 1.0 implementations
    changed their behavior over time as priorities shifted.  The early
    OpenFlow reference implementation, motivated to make every flow a
    microflow to enable hashing, treated inapplicable fields as exact
    matches on a value of 0.  Initially, this behavior was implemented
    in the reference controller only.
  </p>

  <p>
    Later, the reference switch was also changed to actually force any
    wildcarded inapplicable fields into exact matches on 0.  The
    latter behavior sometimes caused problems, because the modified
    flow was the one reported back to the controller later when it
    queried the flow table, and the modifications sometimes meant that
    the controller could not properly recognize the flow that it had
    added.  In retrospect, perhaps this problem should have alerted
    the designers to a design error, but the ability to use a single
    hash table was held to be more important than almost every other
    consideration at the time.
  </p>

  <p>
    When more flexible match formats were introduced much later, they
    disallowed any mention of inapplicable fields as part of a match.
    This raised the question of how to translate between this new
    format and the OpenFlow 1.0 fixed format.  It seemed somewhat
    inconsistent and backward to treat fields as exact-match in one
    format and forbid matching them in the other, so instead the
    treatment of inapplicable fields in the fixed-length format was
    changed from exact match on 0 to wildcarding.  (A better
    classifier had by now eliminated software performance problems
    with wildcards.)
  </p>

  <p>
    The OpenFlow 1.0.1 errata (released only in 2012) added some
    additional explanation [OpenFlow 1.0.1, section 3.4], but it did
    not mandate specific behavior because of variation among
    implementations.
  </p>

  <!-- Future directions: fields are extracted using a fixed idea of
       the protocols in use but many have suggested an offset based
       model.  Cite reconfigurable hardware paper? Difficulties in
       supporting packet modification in this model. -->

  <h3>OpenFlow 1.1</h3>

  <p>
    OpenFlow 1.1 added support for the following fields:
  </p>

  <ul>
    <li>SCTP source and destination port.</li>
    <li>MPLS label and traffic control (TC) fields.</li>
    <li>One 64-bit register (named ``metadata'').</li>
  </ul>

  <p>
    OpenFlow 1.1 increased the size of an ingress port number from 16
    bits to 32 bits.
  </p>

  <p>
    OpenFlow 1.1 increased matching flexibility by introducing
    arbitrary bitwise matching on Ethernet and IPv4 address fields and
    on the new ``metadata'' register field.  Switches were not
    required to support all possible masks [OpenFlow 1.1, section
    4.3].
  </p>

  <p>
    By a strict reading of the specification, OpenFlow 1.1 removed
    support for matching ICMPv4 type and code [OpenFlow 1.1, section
    A.2.3], but this is likely an editing mistake because ICMP
    matching is described elsewhere [OpenFlow 1.1, Table 3, Table 4,
    Figure 4].  Open vSwitch does support ICMPv4 type and code
    matching with OpenFlow 1.1.
  </p>

  <p>
    The OpenFlow 1.1 protocol match format included ``type'' and
    ``length'' members to allow for future flexibility.  Only a single
    type was standardized, one that used a fixed-length data structure
    as in OpenFlow 1.0.  The additional fields and bitwise masks in
    OpenFlow 1.1 caused its standardized match structure to be over
    twice as large as in OpenFlow 1.0, 88 bytes versus 40.
  </p>

  <p>
    OpenFlow 1.1 avoided the pitfalls of inapplicable fields that
    OpenFlow 1.0 encountered, by requiring the switch to ignore the
    specified field values [OpenFlow 1.1, section A.2.3].  It also
    implied that the switch that should ignore the bits that indicate
    whether to match inapplicable fields.
  </p>

  <h4>Physical Ingress Port</h4>

  <p>
    OpenFlow 1.1 introduced a new pseudo-field, the physical ingress
    port (<ref field="MFF_IN_PHY_PORT"/>).  The physical ingress port
    is only a pseudo-field because it appears only one place in the
    protocol: in the ``packet-in'' message that passes a packet
    received at the switch to an OpenFlow controller.  The physical
    ingress port cannot be used for matching.
  </p>

  <p>
    A packet's ingress port and physical ingress port are identical
    except for packets processed by a switch feature such as bonding
    or tunneling that makes a packet appear to arrive on a ``virtual''
    port associated with the bond or the tunnel.  For such packets,
    the ingress port is the virtual port and the physical ingress port
    is, naturally, the physical port.  Open vSwitch implements both
    bonding and tunneling, but its bonding does not use virtual ports
    and its tunnels are typically not on the same switch as their
    physical ingress ports (which need not be part of any switch), so
    the ingress port and physical ingress port are always the same in
    Open vSwitch.
  </p>

  <h3>OpenFlow 1.2</h3>

  <p>
    OpenFlow 1.2 added support for the following fields:
  </p>

  <ul>
    <li>ARP hardware addresses (SHA and THA).</li>
    <li>IPv4 ECN.</li>
    <li>IPv6 source and destination addresses, flow label, DSCP, ECN,
    and protocol.</li>
    <li>TCP, UDP, and SCTP port numbers when encapsulated inside IPv6.</li>
    <li>ICMPv6 type and code.</li>
    <li>ICMPv6 Neighbor Discovery target address and source and target
    Ethernet addresses.</li>
  </ul>

  <p>
    OpenFlow 1.2 abandoned the fixed-length approach to matching.  One
    reason was size, since adding just two of the IPv6 addresses
    mentioned above, with bitwise masks, would have added 64 bytes to
    the match length, increasing it from 88 bytes in OpenFlow 1.1 to
    over 150 bytes.  Extensibility had also become important as
    controller writers increasingly wanted support for new fields
    without having to change messages throughout the OpenFlow
    protocol.  The challenges of carefully defining fixed-length
    matches to avoid problems with inapplicable fields had also become
    clear over time.
  </p>

  <!-- mention tun_id_from_cookie extension? -->

  <p>
    Therefore, OpenFlow 1.2 adopted a flow format using a flexible
    type-length-value representation.  The OpenFlow 1.2 format, called
    <dfn>OXM</dfn> (<dfn>OpenFlow Extensible Match</dfn>), was modeled
    closely on an extension to OpenFlow 1.0 introduced in Open vSwitch
    1.1 called <dfn>NXM</dfn> (<dfn>Nicira Extended Match</dfn>).
    <!-- extensibility was largely successful since 1.3+ just added
         fields -->
  </p>

  <p>
    The OXM and NXM formats use a type/length/value (TLV) format, in
    which each TLV expresses a match on one field.  Each OXM or NXM
    TLV begins with a fixed-length 32-bit header that has the
    following format:
  </p>

  <diagram>
    <header name="type">
      <bits name="vendor/class" above="16" width=".75"/>
      <bits name="field" above="7" width=".4"/>
    </header>
    <nospace/>
    <header name="">
      <bits name="M" above="1" width=".15"/>
      <bits name="length" above="8" width=".4"/>
    </header>
  </diagram>

  <p>
    The most significant 16 bits of the NXM or OXM header, called
    <code>vendor</code> by NXM and <code>class</code> by OXM, identify
    an organization permitted to allocate identifiers for fields.  NXM
    allocates only two vendors, 0x0000 for fields supported by
    OpenFlow 1.0 and 0x0001 for fields implemented as an Open vSwitch
    extension.  OXM assigns classes as follows:
  </p>

  <dl>
    <dt>0x0000 (<code>OFPXMC_NXM_0</code>).</dt>
    <dt>0x0001 (<code>OFPXMC_NXM_1</code>).</dt>
    <dd>Reserved for NXM compatibility.</dd>

    <dt>0x0002 to 0x7fff</dt>
    <dd>
      Reserved for allocation to ONF members, but none yet assigned.
    </dd>

    <dt>0x8000 (<code>OFPXMC_OPENFLOW_BASIC</code>)</dt>
    <dd>
      Used for all standard OpenFlow fields.
    </dd>

    <dt>0x8001 to 0xfffe</dt>
    <dd>
      Reserved for the OpenFlow specification, but none yet assigned.
    </dd>

    <dt>0xffff (<code>OFPXMC_EXPERIMENTER</code>)</dt>
    <dd>Experimental use.</dd>
  </dl>    

  <p>
    When <code>class</code> is 0xffff, the OXM header is extended to
    64 bits by appending a 32-bit <code>experimenter</code> field
    whose most significant byte is zero and whose remaining bytes are
    an Organizationally Unique Identifier (OUI) assigned by the IEEE
    [IEEE OUI], as shown below.  OpenFlow says that support for
    experimenter fields is optional, and Open vSwitch does not
    currently yet support them.
  </p>

  <diagram>
    <header name="type">
      <bits name="class" above="16" below="0xffff" width=".75"/>
      <bits name="field" above="7" width=".4"/>
    </header>
    <nospace/>
    <header name="">
      <bits name="M" above="1" width=".15"/>
      <bits name="length" above="8" width=".4"/>
    </header>

    <header name="experimenter">
      <bits name="zero" above="8" below="0x00" width=".4"/>
      <bits name="OUI" above="32" width="1.1"/>
    </header>
  </diagram>

  <p>
    Taken as a unit, <code>class</code> (or <code>vendor</code>),
    <code>field</code>, and <code>experimenter</code> (when present)
    uniquely identify a particular field.
  </p>


  <p>
    - header/payload, header/payload, ... arrangement
    - order follows prerequisites but not otherwise constrained
    - header identifies a field (also used outside of match as identifier)
    - payload can include a value for exact match or value+mask
    - payload is "length" bytes long (even when M=1).
    - does "length" include or exclude the "experimenter" field size?
      See EXT-482.
    - should diagrams above show the body and its length?
  </p>

  <group title="Tunnel">
    <p>
      The fields in this group relate to tunnels, which Open vSwitch
      supports in several forms (GRE, VXLAN, and so on).  Most of
      these fields do appear in the wire format of a packet, so they
      are data fields from that point of view, but they are metadata
      from an OpenFlow flow table point of view because they do not
      appear in packets that are forwarded to the controller or to
      ordinary (non-tunnel) output ports.
    </p>

    <p>
      Open vSwitch supports a spectrum of usage models for mapping
      tunnels to OpenFlow ports:
    </p>

    <dl>
      <dt>``Port-based'' tunnels</dt>
      <dd>
	<p>
	  In this model, an OpenFlow port represents one tunnel: it
	  matches a particular type of tunnel traffic between two IP
	  endpoints, with a particular tunnel key (if keys are in
	  use).  In this situation, <ref field="MFF_IN_PORT"/>
	  suffices to distinguish one tunnel from another, so the
	  tunnel header fields have little importance for OpenFlow
	  processing.  (They are still populated and may be used if it
	  is convenient.)  The tunnel header fields play no role in
	  sending packets out such an OpenFlow port, either, because
	  the OpenFlow port itself fully specifies the tunnel headers.
	</p>

	<p>
	  The following Open vSwitch commands create a bridge
	  <code>br-int</code>, add port <code>tap0</code> to the
	  bridge as OpenFlow port 1, establish a port-based GRE tunnel
	  between the local host and remote IP 192.168.1.1 using GRE
	  key 5001 as OpenFlow port 2, and arranges to forward all
	  traffic from <code>tap0</code> to the tunnel and vice versa:
	</p>

	<pre>
ovs-vsctl add-br br-int
ovs-vsctl add-port br-int tap0 -- set interface tap0 ofport_request=1
ovs-vsctl add-port br-int gre0 --
    set interface gre0 ofport_request=2 type=gre \
                       options:remote_ip=192.168.1.1 options:key=5001
ovs-ofctl add-flow br-int in_port=1,actions=2
ovs-ofctl add-flow br-int in_port=2,actions=1
	</pre>
      </dd>
      
      <dt>``Flow-based'' tunnels</dt>
      <dd>
	<p>
	  In this model, one OpenFlow port represents all possible
	  tunnels of a given type with an endpoint on the current
	  host, for example, all GRE tunnels.  In this situation, <ref
	  field="MFF_IN_PORT"/> only indicates that traffic was
	  received on the particular kind of tunnel.  This is where
	  the tunnel header fields are most important: they allow the
	  OpenFlow tables to discriminate among tunnels based on their
	  IP endpoints or keys.  Tunnel header fields also determine
	  the IP endpoints and keys of packets sent out such a tunnel
	  port.
	</p>

	<p>
	  The following Open vSwitch commands create a bridge
	  <code>br-int</code>, add port <code>tap0</code> to the
	  bridge as OpenFlow port 1, establish a flow-based GRE tunnel
	  port 3, and arranges to forward all traffic from
	  <code>tap0</code> to remote IP 192.168.1.1 over a GRE tunnel
	  with key 5001 and vice versa:
	</p>

	<pre>
ovs-vsctl add-br br-int
ovs-vsctl add-port br-int tap0 -- set interface tap0 ofport_request=1
ovs-vsctl add-port br-int allgre --
    set interface gre0 ofport_request=2 type=gre \
                       options:remote_ip=flow options:key=flow
ovs-ofctl add-flow br-int \
    'in_port=1 actions=set_tunnel:5001,set_field:192.168.1.1->tun_dst,3'
ovs-ofctl add-flow br-int 'in_port=3,tun_src=192.168.1.1,tun_id=5001 actions=1'
	</pre>
      </dd>

      <dt>Mixed models.</dt>
      <dd>
	<p>
	  One may define both flow-based and port-based tunnels at the
	  same time.  For example, it is valid and possibly useful to
	  create and configure both <code>gre0</code> and
	  <code>allgre</code> tunnel ports described above.
	</p>

	<p>
	  Traffic is attributed on ingress to the most specific
	  matching tunnel.  For example, <code>gre0</code> is more
	  specific than <code>allgre</code>.  Therefore, if both
	  exist, then <code>gre0</code> will be the ingress port for any
	  GRE traffic received from 192.168.1.1 with key 5001.
	</p>

	<p>
	  On egress, traffic may be directed to any appropriate tunnel
	  port.  If both <code>gre0</code> and <code>allgre</code> are
	  configured as already described, then the actions
	  <code>2</code> and
	  <code>set_tunnel:5001,set_field:192.168.1.1->tun_dst,3</code>
	  send the same tunnel traffic.
	</p>
      </dd>

      <dt>Intermediate models.</dt>
      <dd>
	Ports may be configured as partially flow-based.  For example,
	one may define an OpenFlow port that represents tunnels
	between a pair of endpoints but leaves the flow table to
	discriminate on the flow key.
      </dd>
    </dl>

    <p>
      ovs-vswitchd.conf.db(5) describes all the details of tunnel
      configuration.
    </p>

    <p>
      These fields do not have any prerequisites, which means that a
      flow may match on any or all of them, in any combination.
    </p>

    <p>
      These fields are zeros for packets that did not arrive on a tunnel.
    </p>

    <field id="MFF_TUN_ID" title="Tunnel ID">
      <p>
	Many kinds of tunnels support a tunnel ID:
      </p>

      <ul>
	<li>VXLAN has a 24-bit virtual network identifier (VNI).</li>
	<li>LISP has a 24-bit instance ID.</li>
	<li>GRE has an optional 32-bit key.</li>
	<li>
	  GRE64 (a non-standard protocol) has a 64-bit ID constructed
	  from the 32-bit GRE key and 32-bit GRE sequence number.
	</li>
      </ul>

      <p>
	When a packet is received from a tunnel, this field holds the
	tunnel ID in its least significant bits, zero-extended to fit.
	This field is zero if the tunnel does not support an ID, or if
	no ID is in use for a tunnel type that has an optional ID, or
	if an ID of zero received, or if the packet was not received
	over a tunnel.
      </p>

      <p>
	When a packet is output to a tunnel port, the tunnel
	configuration determines whether the tunnel ID is taken from
	this field or bound to a fixed value.  See the earlier
	description of ``port-based'' and ``flow-based'' tunnels for
	more information.
      </p>

      <p>
	The following diagram shows the origin of this field in a
	typical keyed GRE tunnel:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x800" width="0.4"/>
	</header>
	<header name="IPv4">
	  <bits name=". . ." width="0.4"/>
	  <bits name="proto" above="8" below="47" width="0.4"/>
	  <bits name="src" above="32" width="0.4"/>
	  <bits name="dst" above="32" width="0.4"/>
	</header>
	<header name="GRE">
	  <bits name=". . ." above="16" width="0.4"/>
	  <bits name="type" above="16" below="0x6558" width="0.4"/>
	  <bits name="key" above="32" width=".4" fill="yes"/>
	</header>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" width="0.4"/>
	</header>
	<dots/>
      </diagram>  
    </field>

    <field id="MFF_TUN_SRC" title="Tunnel IPv4 Source">
      <p>
	When a packet is received from a tunnel, this field is the
	source address in the outer IP header of the tunneled packet.
	This field is zero if the packet was not received over a
	tunnel.
      </p>

      <p>
	When a packet is output to a flow-based tunnel port, this
	field influences the IPv4 source address used to send the
	packet.  If it is zero, then the kernel chooses an appropriate
	IP address based using the routing table.
      </p>

      <p>
	The following diagram shows the origin of this field in a
	typical keyed GRE tunnel:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x800" width="0.4"/>
	</header>
	<header name="IPv4">
	  <bits name=". . ." width="0.4"/>
	  <bits name="proto" above="8" below="47" width="0.4"/>
	  <bits name="src" above="32" width="0.4" fill="yes"/>
	  <bits name="dst" above="32" width="0.4"/>
	</header>
	<header name="GRE">
	  <bits name=". . ." above="16" width="0.4"/>
	  <bits name="type" above="16" below="0x6558" width="0.4"/>
	  <bits name="key" above="32" width=".4"/>
	</header>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" width="0.4"/>
	</header>
	<dots/>
      </diagram>  
    </field>

    <field id="MFF_TUN_DST" title="Tunnel IPv4 Destination">
      <p>
	When a packet is received from a tunnel, this field is the
	destination address in the outer IP header of the tunneled
	packet.  This field is zero if the packet was not received
	over a tunnel.
      </p>

      <p>
	When a packet is output to a flow-based tunnel port, this
	field specifies the destination to which the tunnel packet is
	sent.
      </p>

      <p>
	The following diagram shows the origin of this field in a
	typical keyed GRE tunnel:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x800" width="0.4"/>
	</header>
	<header name="IPv4">
	  <bits name=". . ." width="0.4"/>
	  <bits name="proto" above="8" below="47" width="0.4"/>
	  <bits name="src" above="32" width="0.4"/>
	  <bits name="dst" above="32" width="0.4" fill="yes"/>
	</header>
	<header name="GRE">
	  <bits name=". . ." above="16" width="0.4"/>
	  <bits name="type" above="16" below="0x6558" width="0.4"/>
	  <bits name="key" above="32" width=".4"/>
	</header>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" width="0.4"/>
	</header>
	<dots/>
      </diagram>  
    </field>

    <!-- Open vSwitch uses the following fields internally, but it
         does not expose them to the user via OpenFlow, so we do not
         document them. -->
    <field id="MFF_TUN_TTL" title="Tunnel IPv4 Time-to-Live" hidden="yes"/>
    <field id="MFF_TUN_TOS" title="Tunnel IPv4 Type of Service" hidden="yes"/>
    <field id="MFF_TUN_FLAGS" title="Tunnel Flags" hidden="yes"/>
  </group>

  <!-- picture -->
  <!-- "what is this field and where does it appear"? -->
  <!--"history" -->

  <group title="Metadata">
    <p>
      These fields relate to the origin or treatment of a packet, but
      they are not extracted from the packet data itself.
    </p>

    <field id="MFF_IN_PORT" title="Ingress Port">
      <p>
	The OpenFlow port on which the packet being processed arrived.
	This is a 16-bit field that holds an OpenFlow 1.0 port number.
	For receiving a packet, the only values that appear in this
	field are:
      </p>

      <dl>
	<dt>1 through <code>0xfeff</code> (65,279), inclusive.</dt>
	<dd>
	  Conventional OpenFlow port numbers.
	</dd>

	<dt><code>OFPP_LOCAL</code> (<code>0xfffe</code> or 65,534).</dt>
	<dd>
	  <p>
	    The ``local'' port, which in Open vSwitch is always named
	    the same as the bridge itself.  This represents a
	    connection between the switch and the local TCP/IP stack.
	    This port is where an IP address is most commonly
	    configured on an Open vSwitch switch.
	  </p>

	  <p>
	    OpenFlow does not require a switch to have a local port,
	    but all existing versions of Open vSwitch have always
	    included a local port.  <b>Future Directions:</b> Future
	    versions of Open vSwitch might be able to optionally omit
	    the local port, if someone submits code to implement such
	    a feature.
	  </p>
	</dd>

	<dt><code>OFPP_NONE</code> (<code>0xffff</code> or 65,535).</dt>
	<dt><code>OFPP_CONTROLLER</code> (<code>0xfffd</code> or 65,533).</dt>
	<dd>
	  <p>
	    When a controller injects a packet into an OpenFlow switch
	    with a ``packet-out'' request, it can specify one of these
	    ingress ports to indicate that the packet was generated
	    internally rather than having been received on some port.
	  </p>

	  <p>
	    OpenFlow 1.0 specified <code>OFPP_NONE</code> for this
	    purpose.  Despite that, some controllers used
	    <code>OFPP_CONTROLLER</code>, and some switches only
	    accepted <code>OFPP_CONTROLLER</code>, so OpenFlow 1.0.2
	    required support for both ports.  OpenFlow 1.1 and later
	    were more clearly drafted to allow only
	    <code>OFPP_CONTROLLER</code>.  For maximum compatibility,
	    Open vSwitch allows both ports with all OpenFlow versions.
	  </p>
	</dd>
      </dl>

      <p>
	Values not mentioned above will never appear when receiving a
	packet, including the following notable values:
      </p>

      <dl>
	<dt>0</dt>
	<dd>
	  Zero is not a valid OpenFlow port number.
	</dd>

	<dt><code>OFPP_MAX</code> (<code>0xff00</code> or 65,280).</dt>
	<dd>
	  This value has only been clearly specified as a valid port
	  number as of OpenFlow 1.3.3.  Before that, its status was
	  unclear, and so Open vSwitch has never allowed
	  <code>OFPP_MAX</code> to be used as a port number, so
	  packets will never be received on this port.  (Other
	  OpenFlow switches, of course, might use it.)
	</dd>

	<dt><code>OFPP_IN_PORT</code> (<code>0xfff8</code> or 65,528)</dt>
	<dt><code>OFPP_TABLE</code> (<code>0xfff9</code> or 65,529)</dt>
	<dt><code>OFPP_NORMAL</code> (<code>0xfffa</code> or 65,530)</dt>
	<dt><code>OFPP_FLOOD</code> (<code>0xfffb</code> or 65,531)</dt>
	<dt><code>OFPP_ALL</code> (<code>0xfffc</code> or 65,532)</dt>
	<dd>
	  These port numbers are used only in output actions and never
	  appear as ingress ports.
	</dd>
      </dl>

      <p>
	Values that will never appear when receiving a packet may
	still be matched against in the flow table.  There are still
	circumstances in which those flows can be matched:
      </p>

      <ul>
	<li>
	  The <code>resubmit</code> Nicira extension action allows a
	  flow table lookup with an arbitrary ingress port.
	</li>

	<li>
	  An action that modifies the ingress port field (see below),
	  such as e.g. <code>load</code> or <code>set_field</code>,
	  followed by an action or instruction that performs another
	  flow table lookup, such as <code>resubmit</code> or
	  <code>goto_table</code>.
	</li>
      </ul>

      <p>
	This field is heavily used for matching in OpenFlow tables,
	but for packet egress, it has only very limited roles:
      </p>

      <ul>
	<li>
	  <p>
	    OpenFlow requires suppressing output actions to <ref
	    field="MFF_IN_PORT"/>.  That is, the following two flows
	    both drop all packets that arrive on port 1:
	  </p>

	  <pre>
in_port=1,actions=1
in_port=1,actions=drop
	  </pre>

	  <p>
	    (This behavior is occasionally useful for flooding to a
	    subset of ports.  Specifying <code>actions=1,2,3,4</code>,
	    for example, outputs to ports 1, 2, 3, and 4, omitting the
	    ingress port.)
	  </p>
	</li>

	<li>
	  OpenFlow has a special port <code>OFPP_IN_PORT</code> (with
	  value 0xfff8) that outputs to the ingress port.  For example,
	  in a switch that has four ports numbered 1 through 4,
	  <code>actions=1,2,3,4,in_port</code> outputs to ports 1, 2,
	  3, and 4, including the ingress port.
	</li>
      </ul>

      <p>
	Because the ingress port field has so little influence on packet
	processing, it does not ordinarily make sense to modify the
	ingress port field.  The field is writable only to support the
	occasional use case where the ingress port's roles in packet
	egress, described above, become troublesome.  For example,
	<code>actions=load:0-&gt;NXM_OF_IN_PORT[],output:123</code>
	will output to port 123 regardless of whether it is in the
	ingress port.  If the ingress port is important, then one may save
	and restore it on the stack:
      </p>

      <pre>
actions=push:NXM_OF_IN_PORT[],load:0->NXM_OF_IN_PORT[],output:123,pop:NXM_OF_IN_PORT[]
      </pre>

      <p>
	The ability to modify the ingress port is an Open vSwitch
	extension to OpenFlow.
      </p>

      <p>
	Modifying the ingress port does not prevent or frustrate
	specifying an ingress port in the <code>resubmit</code> action,
	because <code>resubmit</code> only (optionally) changes the
	in_port used for <code>resubmit</code>'s flow table lookup.
	It does not otherwise affect the ingress port.
      </p>
    </field>

    <field id="MFF_IN_PORT_OXM" title="OXM Ingress Port">
      <p>
	OpenFlow 1.1 and later use a 32-bit port number, so this field
	supplies a 32-bit view of the ingress port.  Current versions of
	Open vSwitch support only a 16-bit range of ports:
      </p>

      <ul>
	<li>
	  OpenFlow 1.0 ports <code>0x0000</code> to
	  <code>0xfeff</code>, inclusive, map to OpenFlow 1.1
	  port numbers with the same values.
	</li>
	
	<li>
	  OpenFlow 1.0 ports <code>0xff00</code> to
	  <code>0xffff</code>, inclusive, map to OpenFlow 1.1 port
	  numbers <code>0xffffff00</code> to <code>0xffffffff</code>.
	</li>

	<li>
	  OpenFlow 1.1 ports <code>0x0000ff00</code> to
	  <code>0xfffffeff</code> are not mapped and not supported.
	</li>
      </ul>

      <p>
	<ref field="MFF_IN_PORT"/> and <ref field="MFF_IN_PORT_OXM"/>
	are two views of the same information, so all of the comments
	on <ref field="MFF_IN_PORT"/> apply to <ref
	field="MFF_IN_PORT_OXM"/> too.  Modifying <ref
	field="MFF_IN_PORT"/> changes <ref field="MFF_IN_PORT_OXM"/>,
	and vice versa.
      </p>

      <p>
	Setting <ref field="MFF_IN_PORT_OXM"/> to an unsupported value
	yields unspecified behavior.
      </p>
    </field>

    <field id="MFF_SKB_PRIORITY" title="Output Queue">
      <p>
	This field influences how packets in the flow will be queued,
	for quality of service (QoS) purposes, when they egress the
	switch.  Its range of meaningful values, and their meanings,
	varies greatly from one OpenFlow implementation to another.
	Even within a single implementation, there is no guarantee
	that all OpenFlow ports have the same queues configured or
	that all OpenFlow ports in an implementation can be configured
	the same way queue-wise.
      </p>

      <p>
	Configuring queues on OpenFlow is not well standardized.  On
	Linux, Open vSwitch supports queue configuration via OVSDB,
	specifically the <code>QoS</code> and <code>Queue</code>
	tables (see <code>ovs-vswitchd.conf.db(5)</code> for details).
	Ports of Open vSwitch to other platforms might require queue
	configuration through some separate protocol (such as a CLI).
	Even on Linux, Open vSwitch exposes only a fraction of the
	kernel's queuing features through OVSDB, so advanced or
	unusual uses might require use of separate utilities
	(e.g. <code>tc</code>).  OpenFlow switches other than Open
	vSwitch might use OF-CONFIG or any of the configuration
	methods mentioned above.  Finally, some OpenFlow switches have
	a fixed number of fixed-function queues (e.g. eight queues
	with strictly defined priorities) and others do not support
	any control over queuing.
      </p>

      <p>
	The only output queue that all OpenFlow implementations must
	support is zero, to identify a default queue, whose properties
	are implementation-defined.  Outputting a packet to a queue
	that does not exist on the output port yields unpredictable
	behavior: among the possibilities are that the packet might be
	dropped or transmitted with a very high or very low priority.
      </p>

      <p>
	OpenFlow 1.0 only allowed output queues to be specified as
	part of an ``enqueue'' action that specified both a queue and
	an output port.  That is, OpenFlow 1.0 treats the queue as an
	argument to an action, not as a field.
      </p>

      <p>
	OpenFlow switch and controller implementers soon realized that
	separating the decisions for output queue and output port
	increased flexibility, so OpenFlow 1.1 added an action to set
	the output queue.  This model was carried forward, without
	change, through OpenFlow 1.4.
      </p>

      <p>
	Open vSwitch implements the native queuing model of each
	OpenFlow version it supports.  Open vSwitch also includes an
	extension for setting the output queue as an action in
	OpenFlow 1.0.
      </p>

      <p>
	When a packet ingresses into an OpenFlow switch, the output
	queue is ordinarily set to 0, indicating the default queue.
	However, Open vSwitch supports various ways to forward a
	packet from one OpenFlow switch to another within a single
	host.  In these cases, Open vSwitch maintains the output queue
	across the forwarding step.  For example:
      </p>

      <ul>
	<li>
	  A hop across a Open vSwitch ``patch port'' (which does not
	  actually involve queuing) preserves the output queue.
	</li>

	<li>
	  <p>
	    When a flow sets the output queue then outputs to an
	    OpenFlow tunnel port, the encapsulation preserves the
	    output queue.  If the kernel TCP/IP stack routes the
	    encapsulated packet directly to a physical interface, then
	    that output honors the output queue.  Alternatively, if
	    the kernel routes the encapsulated packet to another Open
	    vSwitch bridge, then the output queue set previously
	    becomes the initial output queue on ingress to the second
	    bridge and will thus be used for further output actions
	    (unless overridden by a new ``set queue'' action).
	  </p>

	  <p>
	    (This description reflects the current behavior of Open
	    vSwitch on Linux.  This behavior relies on details of the
	    Linux TCP/IP stack.  It could be difficult to make ports
	    to other operating systems behave the same way.)
	  </p>
	</li>
      </ul>

      <p>
	<b>Future Directions:</b> Open vSwitch implements the output
	queue as a field, but does not currently expose it through OXM
	or NXM for matching purposes.  If this turns out to be a
	useful feature, it could be implemented in future versions.
      </p>
    </field>

    <field id="MFF_PKT_MARK" title="Packet Mark">
      <p>
        Packet mark comes to Open vSwitch from the Linux kernel, in
        which the <code>sk_buff</code> data structure that represents
        a packet contains a 32-bit member named <code>skb_mark</code>.
        The value of <code>skb_mark</code> propagates along with the
        packet it accompanies wherever the packet goes in the kernel.
        It has no predefined semantics but various kernel-user
        interfaces can set and match on it, which makes it suitable
        for ``marking'' packets at one point in their handling and
        then acting on the mark later.  With <code>iptables</code>,
        for example, one can mark some traffic specially at ingress
        and then handle that traffic differently at egress based on
        the marked value.
      </p>

      <p>
	Packet mark is an attempt at a generalization of the
	<code>skb_mark</code> concept beyond Linux, at least through
	more generic naming.  Like <ref field="MFF_SKB_PRIORITY"/>,
	packet mark is preserved across forwarding steps within a
	machine.  Unlike <ref field="MFF_SKB_PRIORITY"/>, packet mark
	has no direct effect on packet forwarding: the value set in
	packet mark does not matter unless some later OpenFlow table
	or switch matches on packet mark, or unless the packet passes
	through some other kernel subsystem that has been configured
	to interpret packet mark in specific ways, e.g. through
	<code>iptables</code> configuration mentioned above.
      </p>

      <p>
	Preserving packet mark across kernel forwarding steps relies
	heavily on kernel support, which ports to non-Linux operating
	systems may not have.  Regardless of operating system support,
	Open vSwitch supports packet mark within a single bridge and
	across patch ports.
      </p>

      <p>
	The value of packet mark when a packet ingresses into the
	first Open vSwich bridge is typically zero, but it could be
	nonzero if its value was previously set by some kernel
	subsystem.
      </p>
    </field>

    <field id="MFF_DP_HASH" title="Datapath Hash"/>
    <field id="MFF_RECIRC_ID" title="Datapath Recirculation ID"/>
    <field id="MFF_ACTSET_OUTPUT" title="Action Set Output Port"/>
  </group>

  <group title="Register">
    <p>
      These fields give an OpenFlow switch space for temporary storage
      while the pipeline is running.  Whereas metadata fields can have
      a meaningful initial value and can persist across some hops
      across OpenFlow switches, registers are always initially 0 and
      their values never persist across inter-switch hops.
    </p>

    <field id="MFF_METADATA" title="OpenFlow Metadata">
      <p>
	This field is the only standardized OpenFlow register field.
	Because ASIC-based switches can carry a limited number of
	user-defined bits through their pipelines, OpenFlow allows
	switches to support writing and masking only an
	implementation-defined subset of bits, even no bits at all.
	The Open vSwitch software switch always supports all 64 bits,
	but of course an Open vSwitch port to an ASIC would have the
	same restriction as the ASIC itself.
      </p>

      <p>
	This field has an OXM code point, but OpenFlow 1.1 through 1.4
	allow it to be modified only with a specialized instruction,
	not with a ``set-field'' action.  As of this writing, OpenFlow
	1.5 seems likely to remove this restriction.  Open vSwitch
	does not enforce this restriction, regardless of OpenFlow
	version.
      </p>
    </field>

    <field id="MFF_REG0" title="Register 0">
      This is the first of several Open vSwitch registers, all of
      which have the same properties.  Open vSwitch 1.1 introduced
      registers 0, 1, 2, and 3, version 1.3 added register 4, and
      version 1.7 added registers 5, 6, and 7.
    </field>
    <field id="MFF_REG1" title="Register 1"/>
    <field id="MFF_REG2" title="Register 2"/>
    <field id="MFF_REG3" title="Register 3"/>
    <field id="MFF_REG4" title="Register 4"/>
    <field id="MFF_REG5" title="Register 5"/>
    <field id="MFF_REG6" title="Register 6"/>
    <field id="MFF_REG7" title="Register 7"/>

    <field id="MFF_XREG0" title="Extended Register 0"/>
    <field id="MFF_XREG1" title="Extended Register 1"/>
    <field id="MFF_XREG2" title="Extended Register 2"/>
    <field id="MFF_XREG3" title="Extended Register 3"/>
  </group>

  <group title="Layer 2 (Ethernet)">
    <p>
      Ethernet is the only layer-2 protocol that Open vSwitch
      supports.  As with most software, Open vSwitch and OpenFlow
      regard an Ethernet frame to begin with the 14-byte header and
      end with the final byte of the payload; that is, the frame check
      sequence is not considered part of the frame.
    </p>

    <field id="MFF_ETH_SRC" title="Ethernet Source">
      The Ethernet source address:

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75"/>
	  <bits name="src" above="48" width=".75" fill="yes"/>
	  <bits name="type" above="16" width="0.4"/>
	</header>
	<dots/>
      </diagram>
    </field>

    <field id="MFF_ETH_DST" title="Ethernet Destination">
      <p>
	The Ethernet destination address:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75" fill="yes"/>
	  <bits name="src" above="48" width=".75"/>
	  <bits name="type" above="16" width="0.4"/>
	</header>
	<dots/>
      </diagram>
    </field>

    <field id="MFF_ETH_TYPE" title="Ethernet Type">
      <p>
	The most commonly seen Ethernet frames today use a format
	called ``Ethernet II,'' in which the last two bytes of the
	Ethernet header specify the Ethertype.  For such a frame, this
	field is copied from those bytes of the header, like so:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75"/>
	  <bits name="src" above="48" width=".75"/>
	  <bits name="type" above="16" below="\[&gt;=]0x600" width="0.4" fill="yes"/>
	</header>
	<dots/>
      </diagram>

      <p>
	Every Ethernet type has a value 0x600 (1,536) or greater.
	When the last two bytes of the Ethernet header have a value
	too small to be an Ethernet type, then the value found there
	is the total length of the frame in bytes, excluding the
	Ethernet header.  An 802.2 LLC header typically follows the
	Ethernet header.  OpenFlow and Open vSwitch only support LLC
	headers with DSAP and SSAP <code>0xaa</code> and control byte
	<code>0x03</code>, which indicate that a SNAP header follows
	the LLC header.  In turn, OpenFlow and Open vSwitch only
	support a SNAP header with organization <code>0x000000</code>.
	In such a case, this field is copied from the type field in
	the SNAP header, like this:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75"/>
	  <bits name="src" above="48" width=".75"/>
	  <bits name="type" above="16" below="&lt;0x600" width="0.4"/>
	</header>
	<header name="LLC">
	  <bits name="DSAP" above="8" below="0xaa" width=".4"/>
	  <bits name="SSAP" above="8" below="0xaa" width=".4"/>
	  <bits name="cntl" above="8" below="0x03" width=".4"/>
	</header>
	<header name="SNAP">
	  <bits name="org" above="24" below="0x000000" width=".75"/>
	  <bits name="type" above="16" below="\[&gt;=]0x600" width=".4" fill="yes"/>
	</header>
	<dots/>
      </diagram>

      <p>
	When an 802.1Q header is inserted after the Ethernet source
	and destination, this field is populated with the encapsulated
	Ethertype, not the 802.1Q Ethertype.  With an Ethernet II
	inner frame, the result looks like this:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75"/>
	  <bits name="src" above="48" width=".75"/>
	</header>
	<header name="802.1Q">
	  <bits name="TPID" above="16" below="0x8100" width=".4"/>
	  <bits name="TCI" above="16" width=".4"/>
	</header>
	<header name="Ethertype">
	  <bits name="type" above="16" below="\[&gt;=]0x600" width=".4" fill="yes"/>
	</header>
	<dots/>
      </diagram>

      <p>
	LLC and SNAP encapsulation look like this with an 802.1Q header:
      </p>

      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width=".75"/>
	  <bits name="src" above="48" width=".75"/>
	</header>
	<header name="802.1Q">
	  <bits name="TPID" above="16" below="0x8100" width=".4"/>
	  <bits name="TCI" above="16" width=".4"/>
	</header>
	<header name="Ethertype">
	  <bits name="type" above="16" below="&lt;0x600" width="0.4"/>
	</header>
	<header name="LLC">
	  <bits name="DSAP" above="8" below="0xaa" width=".4"/>
	  <bits name="SSAP" above="8" below="0xaa" width=".4"/>
	  <bits name="cntl" above="8" below="0x03" width=".4"/>
	</header>
	<header name="SNAP">
	  <bits name="org" above="24" below="0x000000" width=".75"/>
	  <bits name="type" above="16" below="\[&gt;=]0x600" width=".4" fill="yes"/>
	</header>
	<dots/>
      </diagram>

      <p>
	When a packet doesn't match any of the header formats described
	above, Open vSwitch and OpenFlow set this field to
	<code>0x5ff</code> (<code>OFP_DL_TYPE_NOT_ETH_TYPE</code>).
      </p>
    </field>
  </group>

  <group title="VLAN">
    <p>
      The 802.1Q VLAN header causes more trouble than any other 4
      bytes in networking.  OpenFlow 1.0, 1.1, and 1.2+ all treat VLANs
      differently.  Nicira extensions add another variant to the mix.
      Open vSwitch reconciles all four treatments as best it can.
    </p>

    <h2>VLAN Header Format</h2>

    <p>
      An 802.1Q VLAN header consists of two 16-bit fields:
    </p>

    <diagram>
      <header name="TPID">
	<bits name="Ethertype" above="16" below="0x8100" width="1.8"/>
      </header>
      <nospace/>
      <header name="TCI">
	<bits name="PCP" above="3" width=".6"/>
	<bits name="CFI" above="1" below="0" width=".3"/>
	<bits name="VID" above="12" width=".9"/>
      </header>
    </diagram>

    <p>
      The first 16 bits of the VLAN header, the <dfn>TPID</dfn> (Tag
      Protocol Identifier), is an Ethertype.  When the VLAN header is
      inserted just after the source and destination MAC addresses in
      a Ethertype frame, the TPID serves to identify the presence of
      the VLAN.  The standard TPID is <code>0x8100</code>.  OpenFlow
      1.0 explicitly supports only TPID <code>0x8100</code>.  OpenFlow
      1.1, but not earlier or later versions, also requires support
      for TPID <code>0x88a8</code>.  OpenFlow 1.2 through 1.4 do not
      require support for specific TPIDs (the ``push vlan header''
      action does say that only <code>0x8100</code> and
      <code>0x88a8</code> should be pushed).  No version of OpenFlow
      provides a way to distinguish or match on the TPID.  Open
      vSwitch only supports TPID <code>0x8100</code>.
    </p>

    <p>
      The remaining 16 bits of the VLAN header, the <dfn>TCI</dfn>
      (Tag Control Information), is subdivided into three subfields:
    </p>

    <ul>
      <li>
	<dfn>PCP</dfn> (Priority Control Point), is a 3-bit 802.1p
	<dfn>priority</dfn>.  The lowest priority is value 1, the
	second-lowest is value 0, and priority increases from 2 up to
	highest priority 7.
      </li>

      <li>
	<dfn>CFI</dfn> (Canonical Format Indicator), is a 1-bit field.
	On an Ethernet network, its value is always 0, and OpenFlow
	and Open vSwitch don't provide ways to match or set a value of
	1.
      </li>

      <li>
	<dfn>VID</dfn> (VLAN IDentifier), is a 12-bit VLAN.  If the
	VID is 0, then the frame is not part of a VLAN.  In that case,
	the VLAN header is called a <dfn>priority tag</dfn> because it
	is only meaningful for assigning the frame a priority.  VID
	<code>0xfff</code> (4,095) is reserved.
      </li>
    </ul>

    <p>
      See <ref field="MFF_ETH_TYPE"/> for illustrations of a
      complete Ethernet frame with 802.1Q tag included.
    </p>

    <p>
      <b>Future Directions:</b> IEEE 802.1ad replaced CFI by
      <dfn>DEI</dfn> (Drop Eligibility Indicator), which is not always
      0.  Future versions of OpenFlow and Open vSwitch might allow
      matching and controlling DEI.
    </p>

    <h2>Multiple VLANs</h2>

    <p>
      Open vSwitch can match only a single VLAN header.  If more than
      one VLAN header is present, then <ref field="MFF_ETH_TYPE"/>
      holds the TPID of the inner VLAN header.  Open vSwitch stops
      parsing the packet after the inner TPID, so matching further
      into the packet (e.g. on the inner TCI or L3 fields) is not
      possible.
    </p>

    <p>
      OpenFlow only directly supports matching a single VLAN header.
      In OpenFlow 1.1 or later, one OpenFlow table can match on the
      outermost VLAN header and pop it off, and a later OpenFlow table
      can matching on the next outermost header.  (Open vSwitch does
      not support this.)
    </p>

    <h2>VLAN Field Details</h2>

    <p>
      The four variants have three different levels of expressiveness:
      OpenFlow 1.0 and 1.1 VLAN matching is strictly less powerful
      than OpenFlow 1.2+ VLAN matching, which is strictly less
      powerful than Nicira extension VLAN matching.
    </p>

    <h2>OpenFlow 1.0 VLAN Fields</h2>

    <p>
      OpenFlow 1.0 uses two fields, called <code>dl_vlan</code> and
      <code>dl_vlan_pcp</code>, with one wildcard bit for each field,
      to specify VLAN matches:
    </p>

    <ul>
      <li>
	When both <code>dl_vlan</code> and <code>dl_vlan_pcp</code> are
	wildcarded, the flow matches packets without an 802.1Q header or
	with any 802.1Q header.
      </li>

      <li>
	When <code>dl_vlan</code> matches on the value
	<code>0xffff</code> (<code>OFP_VLAN_NONE</code>), the flow
	matches only packets without an 802.1Q header.  Such a flow
	should also wildcard <code>dl_vlan_pcp</code>, since a packet
	without an 802.1Q header does not have a PCP.  OpenFlow does not
	specify what to do if a match on PCP is actually present, but
	Open vSwitch ignores it.
      </li>

      <li>
	<p>
	  Otherwise, the flow matches only packets with an 802.1Q
	  header.  If <code>dl_vlan</code> is not wildcarded, then the
	  flow only matches packets with the VLAN ID specified in
	  <code>dl_vlan</code>'s low 12 bits.  If
	  <code>dl_vlan_pcp</code> is not wildcarded, then the flow
	  only matches packets with the priority specified in
	  <code>dl_vlan_pcp</code>'s low 3 bits.
	</p>

	<p>
	  Open vSwitch ignores the high 4 bits of <code>dl_vlan</code>
	  and the high 5 bits of <code>dl_vlan_pcp</code>, although
	  OpenFlow does not specify how to interpret them.
	</p>
      </li>
    </ul>

    <field id="MFF_DL_VLAN" title="OpenFlow 1.0 VLAN ID" hidden="yes"/>
    <field id="MFF_DL_VLAN_PCP" title="OpenFlow 1.0 VLAN Priority"
	   hidden="yes"/>

    <h2>OpenFlow 1.1 VLAN Fields</h2>

    <p>
      VLAN matching in OpenFlow 1.1 is very similar to OpenFlow 1.0.
      The one refinement is that when <code>dl_vlan</code> matches on
      <code>0xfffe</code> (<code>OFVPID_ANY</code>), the flow matches
      only packets with an 802.1Q header, with any VLAN ID.  If
      <code>dl_vlan_pcp</code> is wildcarded, the flow matches any
      packet with an 802.1Q header, regardless of VLAN ID or priority.
      If <code>dl_vlan_pcp</code> is not wildcarded, then the flow
      only matches packets with the priority specified in
      <code>dl_vlan_pcp</code>'s low 3 bits.
    </p>

    <p>
      OpenFlow 1.1 uses the name <code>OFPVID_NONE</code>, instead of
      <code>OFP_VLAN_NONE</code>, for a <code>dl_vlan</code> of
      <code>0xffff</code>, but it has the same meaning.
    </p>

    <p>
      In OpenFlow 1.1, Open vSwitch reports error
      <code>OFPBMC_BAD_VALUE</code> for an attempt to match on
      <code>dl_vlan</code> between 4,096 and <code>0xfffd</code>,
      inclusive, or <code>dl_vlan_pcp</code> greater than 7.
    </p>
    
    <h2>OpenFlow 1.2 VLAN Fields</h2>

    <field id="MFF_VLAN_VID" title="OpenFlow 1.2+ VLAN ID">
      <p>
	The OpenFlow standard describes this field as consisting of
	``12+1'' bits.  On ingress, its value is 0 if no 802.1Q header
	is present, and otherwise it holds the VLAN VID in its least
	significant 12 bits, with bit 12 (<code>0x1000</code> aka
	<code>OFPVID_PRESENT</code>) also set to 1.  The three most
	significant bits are always zero:
      </p>

      <diagram>
	<header name="OXM_OF_VLAN_VID">
	  <bits name="" above="3" below="0" width=".6"/>
	  <bits name="P" above="1" width=".1"/>
	  <bits name="VLAN ID" above="12" width=".9"/>
	</header>
      </diagram>

      <p>
	As a consequence of this field's format, one may use it to
	match the VLAN ID in all of the ways available with the
	OpenFlow 1.0 and 1.1 formats, as well as a few additional
	ways:
      </p>

      <dl>
	<dt>Fully wildcarded</dt>
	<dd>
	  Matches any packet, that is, one without an 802.1Q header or
	  with an 802.1Q header with any TCI value.
	</dd>

	<dt>
	  Value <code>0x0000</code> (<code>OFPVID_NONE</code>), mask
	  <code>0xffff</code> (or no mask)
	</dt>
	<dd>
	  Matches only packets without an 802.1Q header.
	</dd>

	<dt>
	  Value <code>0x1000</code>, mask <code>0x1000</code>
	</dt>
	<dd>
	  Matches any packet with an 802.1Q header, regardless of VLAN
	  ID.
	</dd>

	<dt>
	  Value <code>0x1009</code>, mask <code>0xffff</code> (or no mask)
	</dt>
	<dd>
	  Match only packets with an 802.1Q header with VLAN ID 9.
	</dd>

	<dt>Value <code>0x1001</code>, mask <code>0x1001</code></dt>
	<dd>
	  Matches only packets that have an 802.1Q header with an
	  odd-numbered VLAN ID.  (This is just an example; one can
	  match on any desired VLAN ID bit pattern.)
	</dd>
      </dl>
    </field>

    <field id="MFF_VLAN_PCP" title="OpenFlow 1.2+ VLAN Priority">
      <p>
	The 3 least significant bits may be used to match the PCP bits
	in an 802.1Q header.  Other bits are always zero:
      </p>

      <diagram>
	<header name="OXM_OF_VLAN_VID">
	  <bits name="zero" above="5" below="0" width="1.0"/>
	  <bits name="PCP" above="3" width=".6"/>
	</header>
      </diagram>

      <p>
	May only be used when <ref field="MFF_VLAN_VID"/> is not
	wildcarded and does not exact match on 0 (which only matches
	when there is no 802.1Q header.
      </p>

      <p>
	See <cite>VLAN Comparison Chart</cite>, below, for some examples.
      </p>
    </field>

    <h2>Nicira Extension VLAN Field</h2>

    <p>
      This extension <ref field="MFF_VLAN_TCI"/> can describe more
      kinds of VLAN matches than the other variants.  It is also
      simpler than the other variants.
    </p>

    <field id="MFF_VLAN_TCI" title="VLAN TCI">
      <p>
	For a packet without an 802.1Q header, this field is zero.
	For a packet with an 802.1Q header, this field is the TCI with
	the CFI bit forced to 1.  Thus, for a packet in VLAN 9 with
	priority 7, it has the value <code>0xf009</code>:
      </p>

      <diagram>
	<header name="NXM_VLAN_TCI">
	  <bits name="PCP" above="3" below="7" width=".6"/>
	  <bits name="CFI" above="1" below="1" width=".3"/>
	  <bits name="VID" above="12" below="9" width=".9"/>
	  </header>
      </diagram>

      <p>
	See <cite>VLAN Comparison Chart</cite>, below, for examples.
      </p>
    </field>

    <h2>VLAN Comparison Chart</h2>

    <p>
      The following table describes each of several possible matching
      criteria on 802.1Q header may be expressed with each variation
      of the VLAN matching fields:
    </p>

    <tbl>
r r r r r.
Criteria	OpenFlow 1.0	OpenFlow 1.1	OpenFlow 1.2+	NXM
\_	\_	\_	\_	\_
[1]	\fL????\fR/\fL1\fR,\fL??\fR/\fL?\fR	\fL????\fR/\fL1\fR,\fL??\fR/\fL?\fR	\fL0000\fR/\fL0000\fR,\fL--\fR	\fL0000\fR/\fL0000\fR
[2]	\fLffff\fR/\fL0\fR,\fL??\fR/\fL?\fR	\fLffff\fR/\fL0\fR,\fL??\fR/\fL?\fR	\fL0000\fR/\fLffff\fR,\fL--\fR	\fL0000\fR/\fLffff\fR
[3]	\fL0xxx\fR/\fL0\fR,\fL??\fR/\fL1\fR	\fL0xxx\fR/\fL0\fR,\fL??\fR/\fL1\fR	\fL1xxx\fR/\fLffff\fR,\fL--\fR	\fL1xxx\fR/\fL1fff\fR
[4]	\fL????\fR/\fL1\fR,\fL0y\fR/\fL0\fR	\fLfffe\fR/\fL0\fR,\fL0y\fR/\fL0\fR	\fL1000\fR/\fL1000\fR,\fL0y\fR	\fLz000\fR/\fLf000\fR
[5]	\fL0xxx\fR/\fL0\fR,\fL0y\fR/\fL0\fR	\fL0xxx\fR/\fL0\fR,\fL0y\fR/\fL0\fR	\fL1xxx\fR/\fLffff\fR,\fL0y\fR	\fLzxxx\fR/\fLffff\fR
.T&amp;
r r c c r.
[6]	(none)	(none)	\fL1001\fR/\fL1001\fR,\fL--\fR	\fL1001\fR/\fL1001\fR
.T&amp;
r r c c c.
[7]	(none)	(none)	(none)	\fL3000\fR/\fL3000\fR
[8]	(none)	(none)	(none)	\fL0000\fR/\fL0fff\fR
[9]	(none)	(none)	(none)	\fL0000\fR/\fLf000\fR
[10]	(none)	(none)	(none)	\fL0000\fR/\fLefff\fR
    </tbl>

    <p>
      All numbers in the table are expressed in hexadecimal.  The
      columns in the table are interpreted as follows:
    </p>

    <dl>
      <dt>Criteria</dt>
      <dd>See the list below.</dd>

      <dt>OpenFlow 1.0</dt>
      <dt>OpenFlow 1.1</dt>
      <dd>
	<literal>wwww/x,yy/z</literal> means VLAN ID match value
	<literal>wwww</literal> with wildcard bit <literal>x</literal>
	and VLAN PCP match value <literal>yy</literal> with wildcard
	bit <literal>z</literal>.  <literal>?</literal> means that the
	given bits are ignored (and conventionally
	<literal>0</literal> for <literal>wwww</literal> or
	<literal>yy</literal>, conventionally <literal>1</literal> for
	<literal>x</literal> or <literal>z</literal>).  ``(none)''
	means that OpenFlow 1.0 (or 1.1) cannot match with these
	criteria.
      </dd>

      <dt>OF1.2</dt>
      <dd>
	<literal>xxxx/yyyy,zz</literal> means <ref
	field="MFF_VLAN_VID"/> with value <literal>xxxx</literal> and
	mask <literal>yyyy</literal>, and <ref field="MFF_VLAN_PCP"/>
	(which is not maskable) with value <literal>zz</literal>.
	<literal>--</literal> means that <ref field="MFF_VLAN_PCP"/>
	is omitted.  ``(none)'' means that OpenFlow 1.2 cannot match
	with these criteria.
      </dd>
    
      <dt>NXM</dt>
      <dd>
	<literal>xxxx/yyyy</literal> means <ref field="MFF_VLAN_TCI"/>
	with value <literal>xxxx</literal> and mask
	<literal>yyyy</literal>.
      </dd>
    </dl>

    <p>
      The matching criteria described by the table are:
    </p>

    <dl>
      <dt>[1]</dt>
      <dd>
	Matches any packet, that is, one without an 802.1Q header or
	with an 802.1Q header with any TCI value.
      </dd>

      <dt>[2]</dt>
      <dd>
	<p>
	  Matches only packets without an 802.1Q header.
	</p>

	<p>
	  OpenFlow 1.0 doesn't define the behavior if <ref
	  field="MFF_DL_VLAN"/> is set to <code>0xffff</code> and <ref
	  field="MFF_DL_VLAN_PCP"/> is not wildcarded.  (Open vSwitch
	  always ignores <ref field="MFF_DL_VLAN_PCP"/> when <ref
	  field="MFF_DL_VLAN"/> is set to <code>0xffff</code>.)
	</p>

	<p>
	  OpenFlow 1.1 says explicitly to ignore <ref
	  field="MFF_DL_VLAN_PCP"/> when <ref field="MFF_DL_VLAN"/> is
	  set to <code>0xffff</code>.
	</p>

	<p>
	  OpenFlow 1.2 doesn't say how to interpret a match with <ref
	  field="MFF_VLAN_VID"/> value 0 and a mask with
	  <code>OFPVID_PRESENT</code> (<code>0x1000</code>) set to 1
	  and some other bits in the mask set to 1 also.  Open vSwitch
	  interprets it the same way as a mask of <code>0x1000</code>.
	</p>

	<p>
	  Any NXM match with <ref field="MFF_VLAN_TCI"/> value 0 and
	  the CFI bit set to 1 in the mask is equivalent to the one
	  listed in the table.
	</p>
      </dd>

      <dt>[3]</dt>
      <dd>
	Matches only packets that have an 802.1Q header with VID
	<literal>xxx</literal> (and any PCP).
      </dd>

      <dt>[4]</dt>
      <dd>
	<p>
	  Matches only packets that have an 802.1Q header with PCP
	  <literal>y</literal> (and any VID).
	</p>

	<p>
	  OpenFlow 1.0 doesn't clearly define the behavior for this
	  case.  Open vSwitch implements it this way.
	</p>

	<p>
	  In the NXM value, <literal>z</literal> equals
	  (<literal>y</literal> &lt;&lt; 1) | 1.
	</p>
      </dd>

      <dt>[5]</dt>
      <dd>
	<p>
	  Matches only packets that have an 802.1Q header with VID
	  <literal>xxx</literal> and PCP <literal>y</literal>.
	</p>

	<p>
	  In the NXM value, <literal>z</literal> equals
	  (<literal>y</literal> &lt;&lt; 1) | 1.
	</p>
      </dd>

      <dt>[6]</dt>
      <dd>
	Matches only packets that have an 802.1Q header with an
	odd-numbered VID (and any PCP).  Only possible with OpenFlow
	1.2 and NXM.  (This is just an example; one can match on any
	desired VID bit pattern.)
      </dd>

      <dt>[7]</dt>
      <dd>
	Matches only packets that have an 802.1Q header with an
	odd-numbered PCP (and any VID).  Only possible with NXM.
	(This is just an example; one can match on any desired VID bit
	pattern.)
      </dd>

      <dt>[8]</dt>
      <dd>
	Matches packets with no 802.1Q header or with an 802.1Q header
	with a VID of 0.  Only possible with NXM.
      </dd>

      <dt>[9]</dt>
      <dd>
	Matches packets with no 802.1Q header or with an 802.1Q header
	with a PCP of 0.  Only possible with NXM.
      </dd>

      <dt>[10]</dt>
      <dd>
	Matches packets with no 802.1Q header or with an 802.1Q header
	with both VID and PCP of 0.  Only possible with NXM.
      </dd>
    </dl>
  </group>

  <group title="Layer 2.5: MPLS">
    <p>
      <em>Warning:</em> Open vSwitch support for MPLS is currently
      very limited.  In its current state few users are likely to find
      it useful.
    </p>

    <p>
      One or more MPLS headers (more commonly called <dfn>MPLS
      labels</dfn>) follow an Ethernet type field that specifies an
      MPLS Ethernet type [RFC 3032].  Ethertype <code>0x8847</code> is
      used for all unicast.  Multicast MPLS is divided into two
      specific classes, one of which uses Ethertype
      <code>0x8847</code> and the other <code>0x8848</code> [RFC
      5332].
    </p>

    <p>
      The most common overall packet format is Ethernet II, shown
      below (SNAP encapsulation may be used but is not ordinarily seen
      in Ethernet networks):
    </p>

    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.75"/>
	<bits name="src" above="48" width="0.75"/>
	<bits name="type" above="16" below="0x8847" width="0.4"/>
      </header>
      <header name="MPLS">
	<bits name="label" above="20" width=".6"/>
	<bits name="TC" above="3" width=".3"/>
	<bits name="S" above="1" width=".1"/>
	<bits name="TTL" above="8" width=".4"/>
      </header>
      <dots/>
    </diagram>

    <p>
      MPLS can be encapsulated inside an 802.1Q header, in which case
      the combination looks like this:
    </p>

    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width=".75"/>
	<bits name="src" above="48" width=".75"/>
      </header>
      <header name="802.1Q">
	<bits name="TPID" above="16" below="0x8100" width=".4"/>
	<bits name="TCI" above="16" width=".4"/>
      </header>
      <header name="Ethertype">
	<bits name="type" above="16" below="0x8847" width=".4"/>
      </header>
      <header name="MPLS">
	<bits name="label" above="20" width=".6"/>
	<bits name="TC" above="3" width=".3"/>
	<bits name="S" above="1" width=".1"/>
	<bits name="TTL" above="8" width=".4"/>
      </header>
      <dots/>
    </diagram>

    <p>
      The fields within an MPLS label are:
    </p>

    <dl>
      <dt>Label, 20 bits.</dt>
      <dd>
	An identifier.
      </dd>

      <dt>Traffic control (TC), 3 bits.</dt>
      <dd>
	Used for quality of service.
      </dd>

      <dt>Bottom of stack (BOS), 1 bit (labeled just ``S'' above).</dt>
      <dd>
	<p>
	  0 indicates that another MPLS label follows this one.
	</p>

	<p>
	  1 indicates that this MPLS label is the last one in the
	  stack, so that some other protocol follows this one.
	</p>
      </dd>

      <dt>Time to live (TTL), 8 bits.</dt>
      <dd>
	<p>
	  Each hop across an MPLS network decrements the TTL by 1.  If
	  it reaches 0, the packet is discarded.
	</p>

	<p>
	  OpenFlow and Open vSwitch do not make the MPLS TTL available
	  as a match field, but actions are available to set and
	  decrement the TTL.
	</p>
      </dd>
    </dl>

    <h2>MPLS Label Stacks</h2>

    <p>
      Unlike the other encapsulations supported by OpenFlow and Open
      vSwitch, MPLS labels are routinely used in ``stacks'' two or
      three deep and sometimes even deeper.  An MPLS implementation
      that supports only a single label, as Open vSwitch currently
      does, is not very useful in practice.
    </p>

    <p>
      OpenFlow only supports matching on the outermost MPLS label at
      any given time.  To match on the second label, one must first
      ``pop'' the outer label and advance to another OpenFlow table,
      where the inner label may be matched.  To match on the third
      label, one must pop the two outer labels, and so on.  (Even with
      this approach, Open vSwitch cannot yet match on multiple
      labels.)
    </p>

    <h2>MPLS Inner Protocol</h2>

    <p>
      Unlike all other forms of encapsulation that Open vSwitch and
      OpenFlow support, an MPLS label does not indicate what inner
      protocol it encapsulates.  Different deployments determine the
      inner protocol in different ways [RFC 3032]:
    </p>

    <ul>
      <li>
	A few reserved label values do indicate an inner protcol.
	Label 0, the ``IPv4 Explicit NULL Label,'' indicates inner
	IPv4.  Label 2, the ``IPv6 Explicit NULL Label,'' indicates
	inner IPv6.
      </li>

      <li>
	Some deployments use a single inner protocol consistently.
      </li>

      <li>
	In some deployments, the inner protocol must be inferred from
	the innermost label.
      </li>

      <li>
	In some deployments, the inner protocol must be inferred from
	the innermost label and the encapsulated data, e.g. to
	distinguish between inner IPv4 and IPv6 based on whether the
	first nibble of the inner protocol data are <code>4</code> or
	<code>6</code>.  OpenFlow and Open vSwitch do not currently
	support these cases.
      </li>
    </ul>

    <h2>Future Directions</h2>

    <p>
      Open vSwitch support for MPLS is likely to improve in future
      releases.  Future releases might add some ability to match on an
      MPLS TTL.  The ability to match on the first nibble of
      encapsulated data, which would allow distinguishing encapsulated
      IPv4 and IPv6, has been proposed in the Open Networking
      Foundation Extensibility Working Group [EXT-134].
    </p>

    <p>
      Once Open vSwitch supports multiple labels, it is easy to add an
      OpenFlow extension enabling one to match on more than one label
      in a single table, without popping the outer labels, if that
      proves useful.
    </p>

    <h2>Field Details</h2>

    <field id="MFF_MPLS_LABEL" title="MPLS Label">
      <p>
	The least significant 20 bits hold the ``label'' field from
	the MPLS label.  Other bits are zero:
      </p>

      <diagram>
	<header name="OXM_OF_MPLS_LABEL">
	  <bits name="zero" above="12" below="0" width=".6"/>
	  <bits name="label" above="20" width="1.0"/>
	</header>
      </diagram>

      <p>
	Most label values are available for any use by deployments.
	Values under 16 are reserved.
      </p>
    </field>

    <field id="MFF_MPLS_TC" title="MPLS Traffic Class">
      <p>
	The least significant 3 bits hold the TC field from the MPLS
	label.  Other bits are zero:
      </p>

      <diagram>
	<header name="OXM_OF_MPLS_TC">
	  <bits name="zero" above="5" below="0" width="1.0"/>
	  <bits name="TC" above="3" width=".6"/>
	</header>
      </diagram>

      <p>
	This field is intended for use for Quality of Service (QoS)
	and Explicit Congestion Notification purposes, but its
	particular interpretation is deployment specific.
      </p>

      <p>
	Before 2009, this field was named EXP and reserved for
	experimental use [RFC 5462].
      </p>

      <p><b>References</b></p>

      <p>
      </p>
    </field>

    <field id="MFF_MPLS_BOS" title="MPLS Bottom of Stack">
      <p>
	The least significant bit holds the BOS field from the MPLS
	label.  Other bits are zero:
      </p>

      <diagram>
	<header name="OXM_OF_MPLS_BOS">
	  <bits name="zero" above="7" below="0" width="1.3"/>
	  <bits name="BOS" above="1" width=".3"/>
	</header>
      </diagram>

      <p>
	This field is useful as part of processing a series of
	incoming MPLS labels.  A flow that includes a
	<code>pop_mpls</code> action should generally match on <ref
	field="MFF_MPLS_BOS"/>:
      </p>

      <ul>
	<li>
	  When <ref field="MFF_MPLS_BOS"/> is 1, there is another MPLS
	  label following this one, so the Ethertype passed to
	  <code>pop_mpls</code> should be an MPLS Ethertype.  For
	  example: <code>table=0, dl_type=0x8847, mpls_bos=1,
	  actions=pop_mpls:0x8847, goto_table:1</code>
	</li>

	<li>
	  When <ref field="MFF_MPLS_BOS"/> is 0, this MPLS label is
	  the last one, so the Ethertype passed to
	  <code>pop_mpls</code> should be a non-MPLS Ethertype such as
	  IPv4.  For example: <code>table=1, dl_type=0x8847,
	  mpls_bos=0, actions=pop_mpls:0x0800, goto_table:2</code>
	</li>
      </ul>
    </field>
  </group>

  <group title="Layer 3: IPv4 and IPv6">
    <h2>IPv4 Specific Fields</h2>

    <p>
      These fields apply only to IPv4 flows, that is, flows that match
      on the IPv4 Ethertype <code>0x0800</code>.
    </p>

    <p>
      <b>Future Directions:</b> Open vSwitch and OpenFlow will likely
      add support for protocols, such as LISP [RFC 6830], in which
      IPv4 is the ``root'' field, in other words, where the packet
      begins with an IPv4 header without an Ethernet header.  Support
      will likely be added by adding an alternate prerequisite through
      a proposed ``IP version'' field, so that a controller could
      match on, say, IP version 4 and IPv4 source 192.168.128.1.
    </p>

    <field id="MFF_IPV4_SRC" title="IPv4 Source Address">
      The IPv4 source address:
      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x800" width="0.4"/>
	</header>
	<header name="IPv4">
	  <bits name=". . ." width="0.4"/>
	  <bits name="proto" above="8" width="0.4"/>
	  <bits name="src" above="32" width="0.4" fill="yes"/>
	  <bits name="dst" above="32" width="0.4"/>
	</header>
	<dots/>
      </diagram>
    </field>

    <field id="MFF_IPV4_DST" title="IPv4 Destination Address">
      The IPv4 destination address:
      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x800" width="0.4"/>
	</header>
	<header name="IPv4">
	  <bits name=". . ." width="0.4"/>
	  <bits name="proto" above="8" width="0.4"/>
	  <bits name="src" above="32" width="0.4"/>
	  <bits name="dst" above="32" width="0.4" fill="yes"/>
	</header>
	<dots/>
      </diagram>
    </field>

    <h2>IPv6 Specific Fields</h2>

    <p>
      These fields apply only to IPv6 flows, that is, flows that match
      on the IPv6 Ethertype <code>0x86dd</code>.
    </p>

    <p>
      <b>Future Directions:</b> See <cite>Future Directions</cite> for
      <cite>IPv4 Specific Fields</cite>, above.
    </p>

    <field id="MFF_IPV6_SRC" title="IPv6 Source Address">
      The IPv6 source address:
      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x86dd" width="0.4"/>
	</header>
	<header name="IPv6">
	  <bits name=". . ." width="0.4"/>
	  <bits name="next" above="8" width="0.3"/>
	  <bits name="src" above="128" width="0.8" fill="yes"/>
	  <bits name="dst" above="128" width="0.8"/>
	</header>
	<dots/>
      </diagram>
    </field>
    <field id="MFF_IPV6_DST" title="IPv6 Destination Address">
      The IPv6 destination address:
      <diagram>
	<header name="Ethernet">
	  <bits name="dst" above="48" width="0.4"/>
	  <bits name="src" above="48" width="0.4"/>
	  <bits name="type" above="16" below="0x86dd" width="0.4"/>
	</header>
	<header name="IPv6">
	  <bits name=". . ." width="0.4"/>
	  <bits name="next" above="8" width="0.3"/>
	  <bits name="src" above="128" width="0.8"/>
	  <bits name="dst" above="128" width="0.8" fill="yes"/>
	</header>
	<dots/>
      </diagram>
    </field>
    <field id="MFF_IPV6_LABEL" title="IPv6 Flow Label">
      <p>
	The least significant 20 bits hold the flow label field from
	the IPv6 header.  Other bits are zero:
      </p>

      <diagram>
	<header name="OXM_OF_IPV6_FLABEL">
	  <bits name="zero" above="12" below="0" width=".6"/>
	  <bits name="label" above="20" width="1.0"/>
	</header>
      </diagram>

    </field>

    <field id="MFF_IP_PROTO" title="IPv4/v6 Protocol"/>
    <field id="MFF_IP_DSCP" title="IPv4/v6 DSCP (Bits 2-7)">
      <diagram>
	<header name="NXM_OF_IP_TOS">
	  <bits name="DSCP" above="6" width=".9"/>
	  <bits name="zero" above="2" below="0" width=".3"/>
	</header>
      </diagram>
    </field>
    <field id="MFF_IP_DSCP_SHIFTED" title="IPv4/v6 DSCP (Bits 0-5)">
      <diagram>
	<header name="OXM_OF_IP_DSCP">
	  <bits name="zero" above="2" below="0" width=".3"/>
	  <bits name="DSCP" above="6" width=".9"/>
	</header>
      </diagram>
    </field>
    <field id="MFF_IP_ECN" title="IPv4/v6 ECN">
      <diagram>
	<header name="OXM_OF_IP_ECN">
	  <bits name="zero" above="6" below="0" width=".9"/>
	  <bits name="ECN" above="2" width=".35"/>
	</header>
      </diagram>
    </field>
    <field id="MFF_IP_TTL" title="IPv4/v6 TTL/Hop Limit"/>
    <field id="MFF_IP_FRAG" title="IPv4/v6 Fragment Bitmask">
      <diagram>
	<header name="NXM_NX_IP_FRAG">
	  <bits name="zero" above="6" below="0" width=".9"/>
	  <bits name="later" above="1" width=".3"/>
	  <bits name="any" above="1" width=".3"/>
	</header>
      </diagram>
    </field>
  </group>

  <group title="Layer 3: ARP">
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x806" width="0.4"/>
      </header>
      <header name="ARP">
	<bits name="hrd" above="16" below="1" width=".3"/>
	<bits name="pro" above="16" below="0x800" width=".3"/>
	<bits name="hln" above="8" below="6" width=".2"/>
	<bits name="pln" above="8" below="4" width=".2"/>
	<bits name="op" above="16" width=".2"/>
	<bits name="sha" above="48" width="0.5"/>
	<bits name="spa" above="16" width="0.3"/>
	<bits name="tha" above="48" width="0.5"/>
	<bits name="tpa" above="16" width="0.3"/>
      </header>
    </diagram>
    <field id="MFF_ARP_OP" title="ARP Opcode"/>
    <field id="MFF_ARP_SPA" title="ARP Source IPv4 Address"/>
    <field id="MFF_ARP_TPA" title="ARP Target IPv4 Address"/>
    <field id="MFF_ARP_SHA" title="ARP Source Ethernet Address"/>
    <field id="MFF_ARP_THA" title="ARP Target Ethernet Address"/>
  </group>

  <group title="Layer 4: TCP and UDP">
    <h2>TCP</h2>

    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv4">
	<bits name=". . ." width="0.4"/>
	<bits name="proto" above="8" below="6" width="0.3"/>
	<bits name="src" above="32" width="0.4"/>
	<bits name="dst" above="32" width="0.4"/>
      </header>
      <header name="TCP">
	<bits name="src" above="16" width=".2"/>
	<bits name="dst" above="16" width=".2"/>
	<bits name=". . ." width=".75"/>
	<bits name="flags" above="12" width=".3"/>
	<bits name=". . ." width=".6"/>
      </header>
      <dots/>
    </diagram>
    <field id="MFF_TCP_SRC" title="TCP Source Port"/>
    <field id="MFF_TCP_DST" title="TCP Destination Port">
      <p>
	The TCP destination address.
      </p>

      <p>
	A fairly common requirement is to match on a numerical range
	of TCP sourec or destination ports.  OpenFlow and Open vSwitch
	do not have built-in support for range matching, but one can
	transform range matches into a collection of bitwise matches.
	For example, suppose that the goal is to match TCP source
	ports 1000 to 1999, inclusive.  The binary representations of
	1000 and 1999 are:
      </p>

      <pre fixed="yes">
01111101000
11111001111
      </pre>

      <p>
	The following series of bitwise matches will match 1000 and
	1999 and all the values in between:
      </p>

      <pre fixed="yes">
01111101xxx
0111111xxxx
10xxxxxxxxx
110xxxxxxxx
1110xxxxxxx
11110xxxxxx
1111100xxxx
      </pre>

      <p>
	which can be written as the following in the syntax understood
	by <code>ovs-ofctl</code>:
      </p>

      <pre fixed="yes">
tcp,tp_src=0x03e8/0xfff8
tcp,tp_src=0x03f0/0xfff0
tcp,tp_src=0x0400/0xfe00
tcp,tp_src=0x0600/0xff00
tcp,tp_src=0x0700/0xff80
tcp,tp_src=0x0780/0xffc0
tcp,tp_src=0x07c0/0xfff0
      </pre>
    </field>
    <field id="MFF_TCP_FLAGS" title="TCP Flags">
      <diagram>
	<header>
	  <bits name="zero" above="4" below="0" width=".9"/>
	</header>
	<nospace/>
	<header name="reserved">
	  <bits name="800" above="1" width=".35"/>
	  <bits name="400" above="1" width=".35"/>
	  <bits name="200" above="1" width=".35"/>
	</header>
	<nospace/>
	<header name="later RFCs">
	  <bits name="NS" above="1" width=".35"/>
	  <bits name="CWR" above="1" width=".35"/>
	  <bits name="ECE" above="1" width=".35"/>
	</header>
	<nospace/>
	<header name="RFC 793">
	  <bits name="URG" above="1" width=".35"/>
	  <bits name="ACK" above="1" width=".35"/>
	  <bits name="PSH" above="1" width=".35"/>
	  <bits name="RST" above="1" width=".35"/>
	  <bits name="SYN" above="1" width=".35"/>
	  <bits name="FIN" above="1" width=".35"/>
	</header>
      </diagram>
    </field>

    <h2>UDP</h2>
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv4">
	<bits name=". . ." width="0.4"/>
	<bits name="proto" above="8" below="17" width="0.3"/>
	<bits name="src" above="32" width="0.4"/>
	<bits name="dst" above="32" width="0.4"/>
      </header>
      <header name="UDP">
	<bits name="src" above="16" width=".2"/>
	<bits name="dst" above="16" width=".2"/>
	<bits name=". . ." width=".4"/>
      </header>
      <dots/>
    </diagram>
    <field id="MFF_UDP_SRC" title="UDP Source Port"/>
    <field id="MFF_UDP_DST" title="UDP Destination Port"/>

    <h2>SCTP</h2>
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv4">
	<bits name=". . ." width="0.4"/>
	<bits name="proto" above="8" below="17" width="0.3"/>
	<bits name="src" above="32" width="0.4"/>
	<bits name="dst" above="32" width="0.4"/>
      </header>
      <header name="SCTP">
	<bits name="src" above="16" width=".2"/>
	<bits name="dst" above="16" width=".2"/>
	<bits name=". . ." width=".8"/>
      </header>
      <dots/>
    </diagram>
    <field id="MFF_SCTP_SRC" title="SCTP Source Port"/>
    <field id="MFF_SCTP_DST" title="SCTP Destination Port"/>
  </group>

  <group title="Layer 4: ICMPv4 and ICMPv6">
    <h2>ICMPv4</h2>
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv4">
	<bits name=". . ." width="0.4"/>
	<bits name="proto" above="8" below="1" width="0.3"/>
	<bits name="src" above="32" width="0.4"/>
	<bits name="dst" above="32" width="0.4"/>
      </header>
      <header name="ICMPv4">
	<bits name="type" above="8" width=".3"/>
	<bits name="code" above="8" width=".3"/>
	<bits name=". . ." width=".8"/>
      </header>
      <dots/>
    </diagram>
    <field id="MFF_ICMPV4_TYPE" title="ICMPv4 Type"/>
    <field id="MFF_ICMPV4_CODE" title="ICMPv4 Code"/>

    <h2>ICMPv6</h2>
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv6">
	<bits name=". . ." width="0.2"/>
	<bits name="next" above="8" below="58" width="0.3"/>
	<bits name="src" above="128" width="0.4"/>
	<bits name="dst" above="128" width="0.4"/>
      </header>
      <header name="ICMPv6">
	<bits name="type" above="8" width=".3"/>
	<bits name="code" above="8" width=".3"/>
	<bits name=". . ." width=".8"/>
      </header>
      <dots/>
    </diagram>
    <field id="MFF_ICMPV6_TYPE" title="ICMPv6 Type"/>
    <field id="MFF_ICMPV6_CODE" title="ICMPv6 Code"/>

    <h2>ICMPv6 Neighbor Discovery</h2>
    <diagram>
      <header name="Ethernet">
	<bits name="dst" above="48" width="0.4"/>
	<bits name="src" above="48" width="0.4"/>
	<bits name="type" above="16" below="0x800" width="0.4"/>
      </header>
      <header name="IPv6">
	<bits name=". . ." width="0.2"/>
	<bits name="next" above="8" below="58" width="0.3"/>
	<bits name="src" above="128" width="0.4"/>
	<bits name="dst" above="128" width="0.4"/>
      </header>
      <header name="ICMPv6">
	<bits name="type" above="8" below="135/136" width=".3"/>
	<bits name="code" above="8" below="0" width=".3"/>
	<bits name=". . ." width=".8"/>
      </header>
      <header name="ICMPv6 ND">
	<bits name="target" above="128" width=".4"/>
	<bits name="option . . ." width=".6"/>
      </header>
    </diagram>
    <field id="MFF_ND_TARGET" title="ICMPv6 Neighbor Discovery Target IPv6"/>
    <field id="MFF_ND_SLL"
	   title="ICMPv6 Neighbor Discovery Source Ethernet Address"/>
    <field id="MFF_ND_TLL"
	   title="ICMPv6 Neighbor Discovery Target Ethernet Address"/>
  </group>

  <h1>References</h1>

  <dl>
    <dt>Casado</dt>
    <dd>
      M. Casado, M. J. Freedman, J. Pettit, J. Luo, N. McKeown, and
      S. Shenker, ``Ethane: Taking Control of the Enterprise,''
      Computer Communications Review, October 2007.
    </dd>

    <dt>EXT-56</dt>
    <dd>
      J. Tonsing, ``Permit one of a set of prerequisites to apply, e.g. don't
      preclude non-Ethernet media,'' <url
      href="https://rs.opennetworking.org/bugs/browse/EXT-56"/> (ONF
      members only).
    </dd>

    <dt>EXT-112</dt>
    <dd>
      J. Tourrilhes, ``Support non-Ethernet packets throughout the
      pipeline,'' <url
      href="https://rs.opennetworking.org/bugs/browse/EXT-112"/> (ONF
      members only).
    </dd>

    <dt>EXT-134</dt>
    <dd>
      J. Tourrilhes, ``Match first nibble of the MPLS payload,'' <url
      href="https://rs.opennetworking.org/bugs/browse/EXT-134"/> (ONF
      members only).
    </dd>

    <dt>IEEE OUI</dt>
    <dd>
      IEEE Standards Association, ``MAC Address Block Large (MA-L),''
      <url
      href="https://standards.ieee.org/develop/regauth/oui/index.html"/>.
    </dd>

    <dt>OpenFlow 1.0.1</dt>
    <dd>
      Open Networking Foundation, ``OpenFlow Switch Errata, Version
      1.0.1,'' June 2012.
    </dd>

    <dt>OpenFlow 1.1</dt>
    <dd>
      OpenFlow Consortium, ``OpenFlow Switch Specification Version
      1.1.0 Implemented (Wire Protocol 0x02),'' February 2011.
    </dd>

    <dt>Pepelnjak</dt>
    <dd>
      I. Pepelnjak, ``OpenFlow and Fermi Estimates,'' <url
      href="http://blog.ipspace.net/2013/09/openflow-and-fermi-estimates.html"/>.
    </dd>

    <dt>RFC 793</dt>
    <dd>
      ``Transmission Control Protocol,'' <url
      href="http://www.ietf.org/rfc/rfc793.txt"/>.
    </dd>

    <dt>RFC 3032</dt>
    <dd>
       E. Rosen, D. Tappan, G. Fedorkow, Y. Rekhter, D. Farinacci,
       T. Li, and A. Conta, ``MPLS Label Stack Encoding,'' <url
       href="http://www.ietf.org/rfc/rfc3032.txt"/>.
    </dd>

    <dt>RFC 4632</dt>
    <dd>
      V. Fuller and T. Li, ``Classless Inter-domain Routing (CIDR): The
      Internet Address Assignment and Aggregation Plan,'' <url
      href="https://tools.ietf.org/html/rfc4632"/>.
    </dd>

    <dt>RFC 5462</dt>
    <dd>
      L. Andersson and R. Asati, ``Multiprotocol Label Switching
      (MPLS) Label Stack Entry: ``EXP'' Field Renamed to ``Traffic
      Class'' Field,'' <url
      href="http://www.ietf.org/rfc/rfc5462.txt"/>.
    </dd>

    <dt>RFC 6830</dt>
    <dd>
      D. Farinacci, V. Fuller, D. Meyer, and D. Lewis, ``The
      Locator/ID Separation Protocol (LISP),'' <url
      href="http://www.ietf.org/rfc/rfc6830.txt"/>.
    </dd>

    <dt>Srinivasan</dt>
    <dd>
      V. Srinivasan, S. Suriy, and G. Varghese, ``Packet
      Classification using Tuple Space Search,'' SIGCOMM 1999.
    </dd>

    <dt>Pagiamtzis</dt>
    <dd>
      K. Pagiamtzis and A. Sheikholeslami, ``Content-addressable
      memory (CAM) circuits and architectures: A tutorial and
      survey,'' IEEE Journal of Solid-State Circuits, vol. 41, no. 3,
      pp. 712-727, March 2006.
    </dd>
  </dl>

  <h1>Authors</h1>

  <p>
    Ben Pfaff, with advice from Justin Pettit and Jean Tourrilhes.
  </p>

</fields>

<!--
    OXM fields not yet supported Future Directions References/See Also
    OXM fields required by various versions and by the "Conformance Test Specification for OpenFlow Switch Specification 1.0.1"
-->

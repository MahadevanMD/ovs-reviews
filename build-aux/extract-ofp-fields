#! /usr/bin/python

import getopt
import sys
import os.path
import re
import xml.dom.minidom

line = ""

# Maps from user-friendly version number to its protocol encoding.
VERSION = {"1.0": 0x01,
           "1.1": 0x02,
           "1.2": 0x03,
           "1.3": 0x04,
           "1.4": 0x05,
           "1.5": 0x06}
VERSION_REVERSE = dict((v,k) for k, v in VERSION.iteritems())

TYPES = {"u8": 1,
         "be16": 2,
         "be32": 4,
         "MAC": 6,
         "be64": 8,
         "IPv6": 16}

FORMATTING = {"decimal":            ("MFS_DECIMAL",      1, 8),
              "hexadecimal":        ("MFS_HEXADECIMAL",  1, 8),
              "Ethernet":           ("MFS_ETHERNET",     6, 6),
              "IPv4":               ("MFS_IPV4",         4, 4),
              "IPv6":               ("MFS_IPV6",        16,16),
              "OpenFlow 1.0 port":  ("MFS_OFP_PORT",     2, 2),
              "OpenFlow 1.1+ port": ("MFS_OFP_PORT_OXM", 4, 4),
              "frag":               ("MFS_FRAG",         1, 1),
              "tunnel flags":       ("MFS_TNL_FLAGS",    2, 2),
              "TCP flags":          ("MFS_TCP_FLAGS",    2, 2)}

PREREQS = {"none": "MFP_NONE",
          "ARP": "MFP_ARP",
          "VLAN VID": "MFP_VLAN_VID",
          "IPv4": "MFP_IPV4",
          "IPv6": "MFP_IPV6",
          "IPv4/IPv6": "MFP_IP_ANY",
          "MPLS": "MFP_MPLS",
          "TCP": "MFP_TCP",
          "UDP": "MFP_UDP",
          "SCTP": "MFP_SCTP",
          "ICMPv4": "MFP_ICMPV4",
          "ICMPv6": "MFP_ICMPV6",
          "ND": "MFP_ND",
          "ND solicit": "MFP_ND_SOLICIT",
          "ND advert": "MFP_ND_ADVERT"}

# Maps a name prefix into an (experimenter ID, class) pair, so:
#
#      - Standard OXM classes are written as (0, <oxm_class>)
#
#      - Experimenter OXM classes are written as (<oxm_vender>, 0xffff)
#
# If a name matches more than one prefix, the longest one is used.
OXM_CLASSES = {"NXM_OF_":        (0,          0x0000),
               "NXM_NX_":        (0,          0x0001),
               "OXM_OF_":        (0,          0x8000),
               "OXM_OF_PKT_REG": (0,          0x8001),
               "ONFOXM_ET_":     (0x4f4e4600, 0xffff),

               # This is the experimenter OXM class for Nicira, which is the
               # one that OVS would be using instead of NXM_OF_ and NXM_NX_
               # if OVS didn't have those grandfathered in.  It is currently
               # used only to test support for experimenter OXM, since there
               # are barely any real uses of experimenter OXM in the wild.
               "NXOXM_ET_":      (0x00002320, 0xffff)}
def oxm_name_to_class(name):
    prefix = ''
    class_ = None
    for p, c in OXM_CLASSES.iteritems():
        if name.startswith(p) and len(p) > len(prefix):
            prefix = p
            class_ = c
    return class_

def decode_version_range(range):
    if range in VERSION:
        return (VERSION[range], VERSION[range])
    elif range.endswith('+'):
        return (VERSION[range[:-1]], max(VERSION.values()))
    else:
        a, b = re.match(r'^([^-]+)-([^-]+)$', range).groups()
        return (VERSION[a], VERSION[b])

def get_line():
    global line
    global line_number
    line = input_file.readline()
    line_number += 1
    if line == "":
        fatal("unexpected end of input")

n_errors = 0
def error(msg):
    global n_errors
    sys.stderr.write("%s:%d: %s\n" % (file_name, line_number, msg))
    n_errors += 1

def fatal(msg):
    error(msg)
    sys.exit(1)

def usage():
    argv0 = os.path.basename(sys.argv[0])
    print '''\
%(argv0)s, for extracting OpenFlow field properties from meta-flow.h
usage: %(argv0)s INPUT [--meta-flow | --nx-match]
  where INPUT points to lib/meta-flow.h in the source directory.
Depending on the option given, the output written to stdout is intended to be
saved either as lib/meta-flow.inc or lib/nx-match.inc for the respective C
file to #include.\
''' % {"argv0": argv0}
    sys.exit(0)

def make_sizeof(s):
    m = re.match(r'(.*) up to (.*)', s)
    if m:
        struct, member = m.groups()
        return "offsetof(%s, %s)" % (struct, member)
    else:
        return "sizeof(%s)" % s

def parse_oxms(s, prefix, n_bytes):
    if s == 'none':
        return ()

    return tuple(parse_oxm(s2.strip(), prefix, n_bytes) for s2 in s.split(','))

def parse_oxm(s, prefix, n_bytes):
    m = re.match('([A-Z0-9_]+)\(([0-9]+)\) since(?: OF(1\.[0-9]+) and)? v([12]\.[0-9]+)$', s)
    if not m:
        fatal("%s: syntax error parsing %s" % (s, prefix))
        
    name, oxm_type, of_version, ovs_version = m.groups()

    class_ = oxm_name_to_class(name)
    if class_ is None:
        fatal("unknown OXM class for %s" % name)
    oxm_vendor, oxm_class = class_

    # Normally the oxm_length is the size of the field, but for experimenter
    # OXMs oxm_length also includes the 4-byte experimenter ID.
    oxm_length = n_bytes
    if oxm_class == 0xffff:
        oxm_length += 4
    header = (oxm_vendor, oxm_class, int(oxm_type), oxm_length)

    if of_version:
        if of_version not in VERSION:
            fatal("%s: unknown OpenFlow version %s" % (name, of_version))
        of_version_nr = VERSION[of_version]
        if of_version_nr < VERSION['1.2']:
            fatal("%s: claimed version %s predates OXM" % (name, of_version))
    else:
        of_version_nr = 0

    return (header, name, of_version_nr, ovs_version)

def parse_field(mff, comment):
    f = {'mff': mff}

    # First line of comment is the field name.
    m = re.match(r'"([^"]+)"(?:\s+\(aka "([^"]+)"\))?(?:\s+\(.*\))?\.', comment[0])
    if not m:
        fatal("%s lacks field name" % mff)
    f['name'], f['extra_name'] = m.groups()

    # Find the last blank line the comment.  The field definitions
    # start after that.
    blank = None
    for i in range(len(comment)):
        if not comment[i]:
            blank = i
    if not blank:
        fatal("%s: missing blank line in comment" % mff)

    d = {}
    for key in ("Type", "Maskable", "Formatting", "Prerequisites",
                "Access", "Prefix lookup member",
                "OXM", "NXM", "OF1.0", "OF1.1"):
        d[key] = None
    for fline in comment[blank + 1:]:
        m = re.match(r'([^:]+):\s+(.*)\.$', fline)
        if not m:
            fatal("%s: syntax error parsing key-value pair as part of %s"
                  % (fline, mff))
        key, value = m.groups()
        if key not in d:
            fatal("%s: unknown key" % key)
        elif key == 'Code point':
            d[key] += [value]
        elif d[key] is not None:
            fatal("%s: duplicate key" % key)
        d[key] = value
    for key, value in d.iteritems():
        if not value and key not in ("OF1.0", "OF1.1",
                                     "Prefix lookup member", "Notes"):
            fatal("%s: missing %s" % (mff, key))

    m = re.match(r'([a-zA-Z0-9]+)(?: \(low ([0-9]+) bits\))?$', d['Type'])
    if not m:
        fatal("%s: syntax error in type" % mff)
    type_ = m.group(1)
    if type_ not in TYPES:
        fatal("%s: unknown type %s" % (mff, d['Type']))
    f['n_bytes'] = TYPES[type_]
    if m.group(2):
        f['n_bits'] = int(m.group(2))
        if f['n_bits'] > f['n_bytes'] * 8:
            fatal("%s: more bits (%d) than field size (%d)"
                  % (mff, f['n_bits'], 8 * f['n_bytes']))
    else:
        f['n_bits'] = 8 * f['n_bytes']

    if d['Maskable'] == 'no':
        f['mask'] = 'MFM_NONE'
    elif d['Maskable'] == 'bitwise':
        f['mask'] = 'MFM_FULLY'
    else:
        fatal("%s: unknown maskable %s" % (mff, d['Maskable']))

    fmt = FORMATTING.get(d['Formatting'])
    if not fmt:
        fatal("%s: unknown format %s" % (mff, d['Formatting']))
    if f['n_bytes'] < fmt[1] or f['n_bytes'] > fmt[2]:
        fatal("%s: %d-byte field can't be formatted as %s"
              % (mff, f['n_bytes'], d['Formatting']))
    f['string'] = fmt[0]

    f['prereqs'] = PREREQS.get(d['Prerequisites'])
    if not f['prereqs']:
        fatal("%s: unknown prerequisites %s" % (mff, d['Prerequisites']))

    if d['Access'] == 'read-only':
        f['writable'] = False
    elif d['Access'] == 'read/write':
        f['writable'] = True
    else:
        fatal("%s: unknown access %s" % (mff, d['Access']))

    f['OF1.0'] = d['OF1.0']
    if not d['OF1.0'] in (None, 'exact match', 'CIDR mask'):
        fatal("%s: unknown OF1.0 match type %s" % (mff, d['OF1.0']))
        
    f['OF1.1'] = d['OF1.1']
    if not d['OF1.1'] in (None, 'exact match', 'bitwise mask'):
        fatal("%s: unknown OF1.1 match type %s" % (mff, d['OF1.1']))

    f['OXM'] = (parse_oxms(d['OXM'], 'OXM', f['n_bytes']) +
                parse_oxms(d['NXM'], 'NXM', f['n_bytes']))

    f['prefix'] = d["Prefix lookup member"]

    return f

def protocols_to_c(protocols):
    if protocols == set(['of10', 'of11', 'oxm']):
        return 'OFPUTIL_P_ANY'
    elif protocols == set(['of11', 'oxm']):
        return 'OFPUTIL_P_NXM_OF11_UP'
    elif protocols == set(['oxm']):
        return 'OFPUTIL_P_NXM_OXM_ANY'
    elif protocols == set([]):
        return 'OFPUTIL_P_NONE'
    else:
        assert False        

def autogen_c_comment():
    return [
"/* Generated automatically; do not modify!    -*- buffer-read-only: t -*- */",
""]

def make_meta_flow(meta_flow_h):
    fields = extract_ofp_fields(meta_flow_h)
    output = autogen_c_comment()
    for f in fields:
        output += ["{"]
        output += ["    %s," % f['mff']]
        if f['extra_name']:
            output += ["    \"%s\", \"%s\"," % (f['name'], f['extra_name'])]
        else:
            output += ["    \"%s\", NULL," % f['name']]
        output += ["    %d, %d," % (f['n_bytes'], f['n_bits'])]

        if f['writable']:
            rw = 'true'
        else:
            rw = 'false'
        output += ["    %s, %s, %s, %s,"
                   % (f['mask'], f['string'], f['prereqs'], rw)]

        oxm = f['OXM']
        of10 = f['OF1.0']
        of11 = f['OF1.1']
        if f['mff'] in ('MFF_DL_VLAN', 'MFF_DL_VLAN_PCP'):
            # MFF_DL_VLAN and MFF_DL_VLAN_PCP don't exactly correspond to
            # OF1.1, nor do they have NXM or OXM assignments, but their
            # meanings can be expressed in every protocol, which is the goal of
            # this member.
            protocols = set(["of10", "of11", "oxm"])
        else:
            protocols = set([])
            if of10:
                protocols |= set(["of10"])
            if of11:
                protocols |= set(["of11"])
            if oxm:
                protocols |= set(["oxm"])

        if f['mask'] == 'MFM_FULLY':
            cidr_protocols = protocols.copy()
            bitwise_protocols = protocols.copy()

            if of10 == 'exact match':
                bitwise_protocols -= set(['of10'])
                cidr_protocols -= set(['of10'])
            elif of10 == 'CIDR mask':
                bitwise_protocols -= set(['of10'])
            else:
                assert of10 is None

            if of11 == 'exact match':
                bitwise_protocols -= set(['of11'])
                cidr_protocols -= set(['of11'])
            else:
                assert of11 in (None, 'bitwise mask')
        else:
            assert f['mask'] == 'MFM_NONE'
            cidr_protocols = set([])
            bitwise_protocols = set([])

        output += ["    %s," % protocols_to_c(protocols)]
        output += ["    %s," % protocols_to_c(cidr_protocols)]
        output += ["    %s," % protocols_to_c(bitwise_protocols)]
        
        if f['prefix']:
            output += ["    FLOW_U32OFS(%s)," % f['prefix']]
        else:
            output += ["    -1, /* not usable for prefix lookup */"]

        output += ["},"]
    return output

def make_nx_match(meta_flow_h):
    fields = extract_ofp_fields(meta_flow_h)
    output = autogen_c_comment()
    print "static struct nxm_field_index all_nxm_fields[] = {";
    for f in fields:
        # Sort by OpenFlow version number (nx-match.c depends on this).
        for oxm in sorted(f['OXM'], key=lambda x: x[2]):
            header = ("NXM_HEADER(0x%x,0x%x,%s,0,%d)" % oxm[0])
            print """{ .nf = { %s, %d, "%s", %s } },""" % (
                header, oxm[2], oxm[1], f['mff'])
    print "};"
    return output

def extract_ofp_fields(fn):
    global file_name
    global input_file
    global line_number
    global line

    file_name = fn
    input_file = open(file_name)
    line_number = 0

    fields = []

    while True:
        get_line()
        if re.match('enum.*mf_field_id', line):
            break

    while True:
        get_line()
        first_line_number = line_number
        here = '%s:%d' % (file_name, line_number)
        if (line.startswith('/*')
            or line.startswith(' *')
            or line.startswith('#')
            or not line
            or line.isspace()):
            continue
        elif re.match('}', line) or re.match('\s+MFF_N_IDS', line):
            break

        # Parse the comment preceding an MFF_ constant into 'comment',
        # one line to an array element.
        line = line.strip()
        if not line.startswith('/*'):
            fatal("unexpected syntax between fields")
        line = line[1:]
        comment = []
        end = False
        while not end:
            line = line.strip()
            if line.startswith('*/'):
                get_line()
                break
            if not line.startswith('*'):
                fatal("unexpected syntax within field")

            line = line[1:]
            if line.startswith(' '):
                line = line[1:]
            if line.startswith(' ') and comment:
                continuation = True
                line = line.lstrip()
            else:
                continuation = False

            if line.endswith('*/'):
                line = line[:-2].rstrip()
                end = True
            else:
                end = False

            if continuation:
                comment[-1] += " " + line
            else:
                comment += [line]
            get_line()

        # Drop blank lines at each end of comment.
        while comment and not comment[0]:
            comment = comment[1:]
        while comment and not comment[-1]:
            comment = comment[:-1]

        # Parse the MFF_ constant(s).
        mffs = []
        while True:
            m = re.match('\s+(MFF_[A-Z0-9_]+),?\s?$', line)
            if not m:
                break
            mffs += [m.group(1)]
            get_line()
        if not mffs:
            fatal("unexpected syntax looking for MFF_ constants")

        if len(mffs) > 1 or '<N>' in comment[0]:
            for mff in mffs:
                # Extract trailing integer.
                m = re.match('.*[^0-9]([0-9]+)$', mff)
                if not m:
                    fatal("%s lacks numeric suffix in register group" % mff)
                n = m.group(1)

                # Search-and-replace <N> within the comment,
                # and drop lines that have <x> for x != n.
                instance = []
                for x in comment:
                    y = x.replace('<N>', n)
                    if re.search('<[0-9]+>', y):
                        if ('<%s>' % n) not in y:
                            continue
                        y = re.sub('<[0-9]+>', '', y)
                    instance += [y.strip()]
                fields += [parse_field(mff, instance)]
        else:
            fields += [parse_field(mffs[0], comment)]
        continue

    input_file.close()

    if n_errors:
        sys.exit(1)

    return fields

## ------------------------ ##
## Documentation Generation ##
## ------------------------ ##

def text_to_nroff(s, font=r'\fR'):
    def escape(match):
        c = match.group(0)
        if c.startswith('-'):
            if c != '-' or font == r'\fB':
                return '\\' + c
            else:
                return '-'
        if c == '\\':
            return r'\e'
        elif c == '"':
            return r'\(dq'
        elif c == "'":
            return r'\(cq'
        else:
            fatal("bad escape")

    # Escape - \ " ' as needed by nroff.
    s = re.sub('(-[0-9]|[-"\'\\\\])', escape, s)
    if s.startswith('.'):
        s = '\\' + s
    return s

def escape_nroff_literal(s, font=r'\fB'):
    return font + r'%s\fR' % text_to_nroff(s, font)

def inline_xml_to_nroff(node, font, xfrm=None):
    if node.nodeType == node.TEXT_NODE:
        text = node.data
        if xfrm:
            text = xfrm(text)
        return text_to_nroff(text, font)
    elif node.nodeType == node.ELEMENT_NODE:
        if node.tagName in ['code', 'em', 'option', 'b']:
            s = r'\fB'
            for child in node.childNodes:
                s += inline_xml_to_nroff(child, r'\fB')
            return s + font
        elif node.tagName == 'ref':
            s = r'\fB'
            if node.hasAttribute('field'):
                s += node.attributes['field'].nodeValue
            else:
                fatal("'ref' lacks required attributes: %s" % node.attributes.keys())
            return s + font
        elif node.tagName in ['var', 'dfn', 'i', 'cite']:
            s = r'\fI'
            for child in node.childNodes:
                s += inline_xml_to_nroff(child, r'\fI')
            return s + font
        elif node.tagName in ['literal']:
            s = r'\fL'
            for child in node.childNodes:
                s += inline_xml_to_nroff(child, r'\fL')
            return s + font
        elif node.tagName == 'url':
            return '\n.URL "' + text_to_nroff(node.attributes['href'].nodeValue) + '"\n'
        else:
            fatal("element <%s> unknown or invalid here" % node.tagName)
    else:
        fatal("unknown node %s in inline xml" % node)

def pre_to_nroff(nodes, para, font):
    s = para + '\n.nf\n'
    for node in nodes:
        if node.nodeType != node.TEXT_NODE:
            fatal("<pre> element may only have text children")
        for line in node.data.split('\n'):
            s += escape_nroff_literal(line, font) + '\n.br\n'
    s += '.fi\n'
    return s

def pic_to_nroff(nodes, para):
    s = para + '\n.PS\n'
    for node in nodes:
        if node.nodeType != node.TEXT_NODE:
            fatal("<pic> element may only have text children")
        s += node.data + '\n'
    s += '.PE\n'
    return s

def tbl_to_nroff(nodes, para):
    s = para + '\n.TS\n'
    for node in nodes:
        if node.nodeType != node.TEXT_NODE:
            fatal("<tbl> element may only have text children")
        s += node.data + '\n'
    s += '.TE\n'
    return s

def diagram_header_to_nroff(header_node):
    header_fields = []
    i = 0
    for node in header_node.childNodes:
        if node.nodeType == node.ELEMENT_NODE and node.tagName == 'bits':
            name = node.attributes['name'].nodeValue
            width = node.attributes['width'].nodeValue
            above = node.getAttribute('above')
            below = node.getAttribute('below')
            fill = node.getAttribute('fill')
            header_fields += [{"name": name,
                              "tag": "B%d" % i,
                              "width": width,
                              "above": above,
                              "below": below,
                              "fill": fill}]
            i += 1
        elif node.nodeType == node.COMMENT_NODE:
            pass
        elif node.nodeType == node.TEXT_NODE and node.data.isspace():
            pass
        else:
            fatal("unknown node %s in diagram <header> element" % node)

    s = ""
    for f in header_fields:
        s += "  %s: box \"%s\" width %s" % (f['tag'], f['name'], f['width'])
        if f['fill'] == 'yes':
            s += " fill"
        s += '\n'
    for f in header_fields:
        s += "  \"%s\" at %s.n above\n" % (f['above'], f['tag'])
        s += "  \"%s\" at %s.s below\n" % (f['below'], f['tag'])
    name = header_node.getAttribute('name')
    if name == "":
        visible = " invis"
    else:
        visible = ""
    s += "line <->%s \"%s\" above " % (visible, name)
    s += "from %s.nw + (0,textht) " % header_fields[0]['tag']
    s += "to %s.ne + (0,textht)\n" % header_fields[-1]['tag']
    return s

def diagram_to_nroff(nodes, para):
    s = para + """
.PS
boxht = .2
textht = 1/6
fillval = .2
"""
    move = False
    for node in nodes:
        if node.nodeType == node.ELEMENT_NODE and node.tagName == 'header':
            if move:
                s += "move .1\n"
            s += "[\n" + diagram_header_to_nroff(node) + "]\n"
            move = True
        elif node.nodeType == node.ELEMENT_NODE and node.tagName == 'nospace':
            move = False
        elif node.nodeType == node.ELEMENT_NODE and node.tagName == 'dots':
            s += "move .1\n"
            s += '". . ." ljust\n'
        elif node.nodeType == node.COMMENT_NODE:
            pass
        elif node.nodeType == node.TEXT_NODE and node.data.isspace():
            pass
        else:
            fatal("unknown node %s in diagram <header> element" % node)
    s += '.PE\n'
    return s

def block_xml_to_nroff(nodes, para='.PP'):
    s = ''
    for node in nodes:
        if node.nodeType == node.TEXT_NODE:
            if s == '' and para != '.IP':
                s = para + '\n'
            text = re.sub(r'\s+', ' ', node.data)
            if s.endswith(' '):
                text = text.lstrip()
            s += text_to_nroff(text)
            s = s.lstrip()
        elif node.nodeType == node.ELEMENT_NODE:
            if node.tagName in ['ul', 'ol']:
                if s != "":
                    s += "\n"
                s += ".RS\n"
                i = 0
                for liNode in node.childNodes:
                    if (liNode.nodeType == node.ELEMENT_NODE
                        and liNode.tagName == 'li'):
                        i += 1
                        if node.tagName == 'ul':
                            s += ".IP \\(bu .25in\n"
                        else:
                            s += ".IP %d. .25in\n" % i
                        s += block_xml_to_nroff(liNode.childNodes, ".IP")
                    elif (liNode.nodeType != node.TEXT_NODE
                          or not liNode.data.isspace()):
                        fatal("<%s> element may only have <li> children" % node.tagName)
                s += ".RE\n"
            elif node.tagName == 'dl':
                if s != "":
                    s += "\n"
                s += ".RS\n"
                prev = "dd"
                for liNode in node.childNodes:
                    if (liNode.nodeType == node.ELEMENT_NODE
                        and liNode.tagName == 'dt'):
                        if prev == 'dd':
                            s += '.TP\n'
                        else:
                            s += '.TQ\n'
                        prev = 'dt'
                    elif (liNode.nodeType == node.ELEMENT_NODE
                          and liNode.tagName == 'dd'):
                        if prev == 'dd':
                            s += '.IP\n'
                        prev = 'dd'
                    elif (liNode.nodeType != node.TEXT_NODE
                          or not liNode.data.isspace()):
                        fatal("<dl> element may only have <dt> and <dd> children")
                    s += block_xml_to_nroff(liNode.childNodes, ".IP")
                s += ".RE\n"
            elif node.tagName == 'p':
                if s != "":
                    if not s.endswith("\n"):
                        s += "\n"
                    s += para + "\n"
                s += block_xml_to_nroff(node.childNodes, para)
            elif node.tagName in ('h1', 'h2', 'h3', 'h4'):
                if s != "":
                    if not s.endswith("\n"):
                        s += "\n"
                nroffTag = {'h1': 'SH',
                            'h2': 'SS',
                            'h3': 'ST',
                            'h4': 'SU'}[node.tagName]
                if node.tagName == 'h1':
                    xfrm = lambda s: s.upper()
                else:
                    xfrm = None
                s += ".%s \"" % nroffTag
                for child_node in node.childNodes:
                    s += inline_xml_to_nroff(child_node, r'\fR', xfrm)
                s += "\"\n"
            elif node.tagName == 'pre':
                fixed = node.getAttribute('fixed')
                if fixed == 'yes':
                    font = r'\fL'
                else:
                    font = r'\fB'
                s += pre_to_nroff(node.childNodes, para, font)
            elif node.tagName == 'pic':
                s += pic_to_nroff(node.childNodes, para)
            elif node.tagName == 'diagram':
                s += diagram_to_nroff(node.childNodes, para)
            elif node.tagName == 'tbl':
                s += tbl_to_nroff(node.childNodes, para)
            else:
                s += inline_xml_to_nroff(node, r'\fR')
        elif node.nodeType != node.COMMENT_NODE:
            fatal("unknown node %s in block xml" % node)
    if s != "" and not s.endswith('\n'):
        s += '\n'
    return s

def oxm_to_nroff(oxm):
    header, name, of_version_nr, ovs_version = oxm
    oxm_vendor, oxm_class, oxm_type, oxm_length = header
    s = "\\fB%s\\fR(%d) since" % (name, oxm_type)
    if of_version_nr:
        s += " OpenFlow %s and" % VERSION_REVERSE[of_version_nr]
    s += " Open vSwitch %s" % ovs_version
    return s

def field_to_xml(field_node, f):
    f["used"] = True
    if field_node.hasAttribute('hidden'):
        return ''

    title = field_node.attributes['title'].nodeValue

    s = """.PP
\\fB%s Field\\fR
.TS
tab(;);
l lx.
""" % title

    s += "Name:;\\fB%s\\fR" % f["name"]
    if f["extra_name"]:
        s += " (aka \\fB%s\\fR)" % f["extra_name"]
    s += '\n'

    s += "Width:;"
    if f["n_bits"] == 8 * f["n_bytes"]:
        s += "%d bits" % f["n_bits"]
    else:
        s += "%d bits (only the least-significant %d bits may be nonzero)" % (
            f["n_bytes"] * 8, f["n_bits"])
    s += '\n'

    masks = {"MFM_NONE": "not maskable",
             "MFM_FULLY": "arbitrary bitwise masks"}
    s += "Masking:;%s\n" % masks[f["mask"]]
    s += "Prerequisites:;%s\n" % f["prereqs"]

    access = {True: "read/write",
              False: "read-only"}[f["writable"]]
    s += "Access:;%s\n" % access

    of10 = {None: "not supported",
            "exact match": "yes (exact match only)",
            "CIDR mask": "yes (CIDR match only)"}
    s += "OpenFlow 1.0:;%s\n" % of10[f["OF1.0"]]

    of11 = {None: "not supported",
            "exact match": "yes (exact match only)",
            "bitwise mask": "yes"}
    s += "OpenFlow 1.1:;%s\n" % of11[f["OF1.1"]]

    s += "OXM/NXM:;"
    oxms = sorted(f['OXM'], key=lambda x: x[2])
    if not oxms:
        s += "none\n";
    else:
        s += oxm_to_nroff(oxms[0]) + "\n"
        for oxm in oxms[1:]:
            s += ";" + oxm_to_nroff(oxm) + "\n"

    """
    oxm_name = f["oxm_name"]
    nxm_name = f["nxm_name"]
    for name, protocol in (("OpenFlow 1.0", P_OF10),
                           ("OpenFlow 1.1", P_OF11),
                           ("OpenFlow 1.2", P_OF12),
                           ("OpenFlow 1.3", P_OF13),
                           ("NXM",          P_NXM)):
        if f["usable_protocols"] & protocol:
            support = "yes"
            if (f["usable_protocols_bitwise"] & protocol
                or f["maskable"] == "MFM_NONE"):
                pass
            elif id_ in ("MFF_IPV4_SRC", "MFF_IPV4_DST",
                         "MFF_ARP_SPA" "MFF_ARP_TPA"):
                support += " (CIDR masks only)"
            else:
                support += " (exact match only)"

            if protocol & (P_OF12 | P_OF13):
                if oxm_name.startswith("NXM"):
                    support += " (via NXM code point)"
                elif (protocol == P_OF12
                      and oxm_name and oxm_version[oxm_name] == "1.3"):
                    support += " (via OpenFlow 1.3 code point)"
            elif protocol == P_NXM:
                if nxm_name.startswith("OXM"):
                    support += " (via OXM code point)"
                elif id_ == "MFF_ETH_DST":
                    support += " (only partially maskable before Open vSwitch 1.8, see notes)"
                elif id_ in ("MFF_IPV4_SRC", "MFF_IPV4_DST",
                             "MFF_IPV6_SRC", "MFF_IPV6_DST",
                             "MFF_ARP_SPA" "MFF_ARP_TPA",
                             "MFF_ND_TARGET"):
                    support += " (CIDR masks only before Open vSwitch 1.8)"
                elif (nxm_name
                      and f["maskable"] != "MFM_NONE"
                      and nxm_version[nxm_name] != nxm_version[nxm_name + '_W']):
                    support += " (maskable since Open vSwitch %s)" % nxm_version[nxm_name + '_W']
        else:
            support = "no"
            
        s += "%s:;%s\n" % (name, support)

    s += "Code Points:;"
    if not oxm_name:
        s += "none\n"
    else:
        s += code_point_to_nroff(oxm_name)
        if oxm_name != nxm_name:
            s += ";" + code_point_to_nroff(nxm_name)
"""
    s += ".TE\n"

    s += '.PP\n'
    s += block_xml_to_nroff(field_node.childNodes)
        
    return s

def group_xml_to_nroff(group_node, fields):
    s = '.bp\n'
    title = group_node.attributes['title'].nodeValue
    s += '.SH \"%s\"\n' % text_to_nroff(title.upper() + " FIELDS")

    for node in group_node.childNodes:
        if (node.nodeType == node.ELEMENT_NODE
            and node.tagName in ('field', 'group')):
            id_ = node.attributes['id'].nodeValue
            s += field_to_xml(node, fields[id_])
        else:
            s += block_xml_to_nroff([node])
    return s

def make_ovs_fields(meta_flow_h, meta_flow_xml):
    fields = extract_ofp_fields(meta_flow_h)
    fields_map = {}
    for f in fields:
        fields_map[f['mff']] = f

    doc = xml.dom.minidom.parse(meta_flow_xml).documentElement

    global version
    if version == None:
        version = "UNKNOWN"

    print '''\
'\\" tp
.\\" -*- mode: troff; coding: utf-8 -*-
.TH "ovs\-fields" 7 "%s" "Open vSwitch" "Open vSwitch Manual"
.fp 5 L CR              \\" Make fixed-width font available as \\fL.
.de ST
.  PP
.  RS -0.15in
.  I "\\\\$1"
.  RE
..

.de SU
.  PP
.  I "\\\\$1"
..

.de IQ
.  br
.  ns
.  IP "\\\\$1"
..
.de URL
\\\\$2 \\(laURL: \\\\$1 \\(ra\\\\$3
..
.if \\n[.g] .mso www.tmac
.SH NAME
ovs\-fields \- protocol header fields in OpenFlow and Open vSwitch
.
.PP
''' % version

    s = ''
    for node in doc.childNodes:
        if node.nodeType == node.ELEMENT_NODE and node.tagName == "group":
            s += group_xml_to_nroff(node, fields_map)
        elif node.nodeType == node.TEXT_NODE:
            assert node.data.isspace()
        elif node.nodeType == node.COMMENT_NODE:
            pass
        else:
            s += block_xml_to_nroff([node])

    for f in fields:
        if "used" not in f:
            error("%s: field not documented" % f["mff"])
    if n_errors:
        sys.exit(1)
            
    for oline in s.split("\n"):
        oline = oline.strip()

        # Life is easier with nroff if we don't try to feed it Unicode.
        # Fortunately, we only use a few characters outside the ASCII range.
        oline = oline.replace(u'\u2208', r'\[mo]')
        oline = oline.replace(u'\u2260', r'\[!=]')
        oline = oline.replace(u'\u2264', r'\[<=]')
        if len(oline):
            print oline

## ------------ ##
## Main Program ##
## ------------ ##

if __name__ == "__main__":
    argv0 = sys.argv[0]
    try:
        options, args = getopt.gnu_getopt(sys.argv[1:], 'h',
                                          ['help', 'ovs-version='])
    except getopt.GetoptError, geo:
        sys.stderr.write("%s: %s\n" % (argv0, geo.msg))
        sys.exit(1)

    global version
    version = None
    for key, value in options:
        if key in ['-h', '--help']:
            usage()
        elif key == '--ovs-version':
            version = value
        else:
            sys.exit(0)

    if not args:
        sys.stderr.write("%s: missing command argument "
                         "(use --help for help)\n" % argv0)
        sys.exit(1)

    commands = {"meta-flow": (make_meta_flow, 1),
                "nx-match": (make_nx_match, 1),
                "ovs-fields": (make_ovs_fields, 2)}

    if not args[0] in commands:
        sys.stderr.write("%s: unknown command \"%s\" "
                         "(use --help for help)\n" % (argv0, args[0]))
        sys.exit(1)

    func, n_args = commands[args[0]]
    if len(args) - 1 != n_args:
        sys.stderr.write("%s: \"%s\" requires %d arguments but %d "
                         "provided\n"
                         % (argv0, args[0], n_args, len(args) - 1))
        sys.exit(1)

    func(*args[1:])

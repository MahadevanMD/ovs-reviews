AT_BANNER([P4])

AT_SETUP([P4 -- lexer])
dnl For lines without =>, input and expected output are identical.
dnl For lines with =>, input precedes => and expected output follows =>.
AT_DATA([test-cases.txt], [dnl
foo bar baz quuxquuxquux _abcd_ a123_
"abc\u0020def" => "abc def"
" => error("Input ends inside quoted string.")dnl "

apply current default else hit if last latest parse_error payload select switch

a/*b*/c => a c
a//b c => a
a/**/b => a b
a/*/b => a error("`/*' without matching `*/'.")
a/*/**/b => a b
a/b => a / b

dnl Examples from 1.0.2 spec:
42 => 42(w6)
16'42
0b101010 => 0b101010(w6)
0'0x2a => 0x2a(w6)
12'0x100
7'0b1 => 7'0b1
-0B101 => 0b1011(w4)

0 => 0(w1)
1 => 1(w1)
12345 => 12345(w14)
-12345 => 20423(w15)
16'12345 => 16'12345
+16'12345 => 16'12345
-16'12345 => 53191(w16)
-16'53191 => 16'12345
-15'53191 => error("Constant width 15 is less than natural width 16.")
18446744073709551615 => 18446744073709551615(w64)
-18446744073709551615 => 0x10000000000000001(w65)
18446744073709551616 => error("Decimal constants must be less than 2**64.")
-18446744073709551616 => error("Decimal constants must be less than 2**64.")
9999999999999999999999 => error("Decimal constants must be less than 2**64.")
01 => error("Decimal constants must not have leading zeros.")
1x => error("Constant followed by unexpected character `x'.")

1024'0 => error("Width must be between 0 and 128.")

0x1234 => 0x1234(w13)
0x01234 => 0x1234(w13)
+0x1234 => 0x1234(w13)
+0x01234 => 0x1234(w13)
-0x1234 => 0x2dcc(w14)
-0x01234 => 0x2dcc(w14)
16'0x123 => 16'0x123
+16'0x123 => 16'0x123
-16'0x123 => 0xfedd(w16)
-16'0xfffe => 16'0x2
0x0 => 0(w1)
0x000 => 0(w1)
0xfedcba9876543210 => 0xfedcba9876543210(w64)
0xfedc_ba98_7654_3210 => 0xfedcba9876543210(w64)
0XFEDCBA9876543210 => 0xfedcba9876543210(w64)
0xfedcba9876543210fedcba9876543210 => 0xfedcba9876543210fedcba9876543210(w128)
0xfedcba9876543210fedcba98765432100 => error("Constant exceeds supported 128-bit width.")
0x0000fedcba9876543210fedcba9876543210 => 0xfedcba9876543210fedcba9876543210(w128)
0x => error("Digits expected following `0x'.")
0X => error("Digits expected following `0X'.")
0x_ => 0 => error("Digits expected following `0x'.")

0b1010 => 0b1010(w4)
0b1001000110100 => 0b1001000110100(w13)
-0b1001000110100 => 0b10110111001100(w14)
-16'0b1001000110100 => 0b1110110111001100(w16)
-16'0b1111_1111_1111_1111 => 16'0b1
0b2 => error("`2' is not a valid base-2 digit.")
0b => 0 => error("Digits expected following `0b'.")
0B_ => 0 => error("Digits expected following `0B'.")
0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 => 0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000(w128)
0b00010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 => 0b10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000(w128)
0b110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 => error("Constant exceeds supported 128-bit width.")
3'0b1011 => error("Constant width 3 is less than natural width 4.")

+-*/%<<>>|&^~ => + - * / % << >> | & ^ ~
(){}[[]]==!=<><=>=.,:; => ( ) { } [[ ]] == != < > <= >= . , : ;

= => error("`=' is only valid as part of `=='.")
! => error("'!' is only valid as part of `!='.")

` => error("Invalid character ``' in input.")
])
AT_CAPTURE_FILE([input.txt])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-p4 lex < input.txt], [0], [expout])
AT_CLEANUP

AT_SETUP([P4 -- parser positive tests])
AT_DATA([test.p4], [dnl
header_type ethernet_t {
    fields {
        dst : 48;
	src : 48;
        type : 16;
    }
}

header_type vlan_t {
    fields {
	pcp : 3;
	cfi : 1;
	vid : 12;
	type : 16;
    }
}

header_type ipv4_t {
    fields {
	ip_version : 4;
	ip_hdrlen : 4;
	ip_dscp : 6;
        ip_ecn : 2;
	ip_tot_len : 16;
	ip_id : 16;
	ip_flags : 3;
	ip_frag_off : 13;
	ip_ttl : 8;
	ip_proto : 8;
	ip_csum : 16;
	ip_src : 32;
	ip_dst : 32;
	ip_options : *;
    }
    length : ip_hdrlen * 4;
    max_length : 60;
}

header_type mpls_t {
    fields {
        label : 20;
	tc : 3;
	bos : 1;
	ttl : 8;
    }
}

header ethernet_t ethernet;
header vlan_t vlan;
header mpls_t mpls[[5]];
header ipv4_t ipv4;

header_type md_t {
    fields {
        a : 8;
	b : 8 (signed);
	c : 8 (saturating);
	d : 8 (signed, saturating);
	e : 8 (saturating, signed);
    }
}

metadata md_t md { a: 5; b: -1; c: 0xff; d: -127; };

parser start {
    return ethernet;
}

parser ethernet {
    extract(ethernet);
    return select(latest.type) {
	0x0800: ipv4;
	0x8100: vlan;
	0x8847: mpls;
	0x8848: mpls;
	0x0000: parse_error;
	default: ingress;
    }
}

parser mpls {
    extract(mpls[[next]]);
    return select(latest.bos) {
        0: mpls;
	1: ingress;
    }
}

parser vlan {
    extract(vlan);
    set_metadata(md.a, 0);
    set_metadata(md.b, latest.type);
    set_metadata(md.c, current(10, 8));
    set_metadata(md.d, ipv4.ip_proto);
    set_metadata(md.e, mpls[[last]].ttl);
    return select(latest.type) {
	0x0800: ipv4;
	default: ingress;
    }
}

parser ipv4 {
    extract(ipv4);
    return ingress;
}

parser foo {
    extract(mpls[[0]]);
    extract(mpls[[1]]);
    extract(mpls[[2]]);
    return ingress;
}

parser bar {
    return parse_error;
}

parser quux {
    return foo;
}
])
AT_DATA([expout],
[[header_type ethernet_t {
    fields {
        dst : 48;
        src : 48;
        type : 16;
    }
}

header_type ipv4_t {
    fields {
        ip_version : 4;
        ip_hdrlen : 4;
        ip_dscp : 6;
        ip_ecn : 2;
        ip_tot_len : 16;
        ip_id : 16;
        ip_flags : 3;
        ip_frag_off : 13;
        ip_ttl : 8;
        ip_proto : 8;
        ip_csum : 16;
        ip_src : 32;
        ip_dst : 32;
        ip_options : *;
    }
    length : ip_hdrlen * 4;
    max_length : 60;
}

header_type md_t {
    fields {
        a : 8;
        b : 8 (signed);
        c : 8 (saturating);
        d : 8 (signed, saturating);
        e : 8 (signed, saturating);
    }
}

header_type mpls_t {
    fields {
        label : 20;
        tc : 3;
        bos : 1;
        ttl : 8;
    }
}

header_type vlan_t {
    fields {
        pcp : 3;
        cfi : 1;
        vid : 12;
        type : 16;
    }
}

header ethernet_t ethernet;
header ipv4_t ipv4;
metadata md_t md {
    a : 0x5;
    b : 0xff;
    c : 0xff;
    d : 0x81;
};
header mpls_t mpls[5];
header vlan_t vlan;

parser start {
    return ethernet;
}

parser ethernet {
    extract(ethernet);
    return select(ethernet.type) {
        0x800: ipv4;
        0x8100: vlan;
        0x8847: mpls;
        0x8848: mpls;
        0: parse_error;
        default: ingress;
    }
}

parser ipv4 {
    extract(ipv4);
    return ingress;
}

parser vlan {
    extract(vlan);
    set_metadata(md.a, 0);
    set_metadata(md.b, vlan.type);
    set_metadata(md.c, current(10, 8));
    set_metadata(md.d, ipv4.ip_proto);
    set_metadata(md.e, mpls[last].ttl);
    return select(vlan.type) {
        0x800: ipv4;
        default: ingress;
    }
}

parser mpls {
    extract(mpls[next]);
    return select(mpls[last].bos) {
        0: mpls;
        0x1: ingress;
    }
}

parser bar {
    parse_error;
}

parser foo {
    extract(mpls[0]);
    extract(mpls[1]);
    extract(mpls[2]);
    return ingress;
}

parser quux {
    return foo;
}
]])
AT_CHECK([ovstest test-p4 parse test.p4], [0], [expout])
# Parsing should yield a fixed point, so passing the output back through the
# same test should not change anything:
AT_CHECK([ovstest test-p4 parse expout], [0], [expout])
AT_CLEANUP

AT_SETUP([P4 -- header_type parser negative tests])
AT_CHECK([echo 'header_type current {};' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `current' expecting header_type name
])
AT_CHECK([echo 'header_type a { fields { x : 8; } }
header_type a;' | ovstest test-p4 parse -], [1], [],
    [-:2: error: duplicate header_type name `a'
])
AT_CHECK([echo 'header_type a { fields { a : *; b : 8; } }' | ovstest test-p4 parse -],
    [1], [], [-:1: error: variable-width field must be last field
])
AT_CHECK([echo 'header_type a { fields { : 8; } }' | ovstest test-p4 parse -],
    [1], [], [-:1: syntax error at `:' expecting field name
])
AT_CHECK([echo 'header_type a { fields { b : 8; b : 8; } }' | ovstest test-p4 parse -],
    [1], [], [-:1: error: duplicate field name `b'
])
AT_CHECK([echo 'header_type a { fields { a : 4; b : *; } }' | ovstest test-p4 parse -],
    [1], [], [-:1: error: variable-width field must begin on byte boundary
])
AT_CHECK([echo 'header_type a { fields { a : 8 (unsigned); } }' | ovstest test-p4 parse -],
    [1], [], [-:1: syntax error at `unsigned' expecting `signed' or `saturating'
])
AT_CHECK([echo 'header_type a { fields { a : 4; } }' | ovstest test-p4 parse -],
    [1], [], [-:1: error: header_type length must be multiple of 8 bits
])
AT_CHECK([echo 'header_type a { fields { a : 8; } length : 8; }' | ovstest test-p4 parse -],
    [0], [/*
-:1: warning: ignoring `length' for fixed-width header_type `a'
*/

header_type a {
    fields {
        a : 8;
    }
}

])
AT_CHECK([echo 'header_type a { fields { a : 32; b : *; } length: a + 4; max_length: 2 }' | ovstest test-p4 parse -],
    [1], [], [-:1: error: max_length 2 for header_type a is less than sum of 4 bytes for fixed-width fields
])
AT_CHECK([echo 'header_type a { fields { a : 8; } max_length : 8; }' | ovstest test-p4 parse -],
    [0], [/*
-:1: warning: ignoring `max_length' for fixed-width header_type `a'
*/

header_type a {
    fields {
        a : 8;
    }
}

])
AT_CLEANUP

AT_SETUP([P4 -- instance parser negative tests])
AT_CHECK([echo 'header;' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `;' expecting header_type name
])
AT_CHECK([echo 'header xyzzy;' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `xyzzy' expecting header_type name
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : *; } length : 123; }
metadata xyzzy' | ovstest test-p4 parse -], [1], [],
    [-:2: error: metadata instances may not have variable-length header types
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : 8; } }
header xyzzy;' | ovstest test-p4 parse -], [1], [],
    [-:2: syntax error at `;' expecting instance name
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : 8; } }
header xyzzy x;
header xyzzy x;' | ovstest test-p4 parse -], [1], [],
    [-:3: error: duplicate instance name `x'
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : 8; } }
metadata xyzzy x[[2]];' | ovstest test-p4 parse -], [1], [],
    [-:2: error: metadata instances may not be arrays
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : 8; } }
header xyzzy x { foo: 1 };' | ovstest test-p4 parse -], [1], [],
    [-:2: error: only metadata instances may have initializers
])
AT_CHECK([echo 'header_type xyzzy { fields { foo : 8; } }
metadata xyzzy x { foo: 0x100 };' | ovstest test-p4 parse -], [1], [],
    [-:2: error: can't initialize 8-bit field foo with 9-bit constant
])
AT_CLEANUP

AT_SETUP([P4 -- parse function parser negative tests])
AT_CHECK([echo 'parser;' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `;' expecting parser name
])
AT_CHECK([echo 'parser x { return ingress; }
parser x;' | ovstest test-p4 parse -], [1], [],
    [-:2: error: duplicate parser state name `x'
])
AT_CHECK([echo 'header_type h { fields { f: 8; } }
metadata h m;
parser x { extract(m); }' | ovstest test-p4 parse -], [1], [],
    [-:3: error: cannot extract a metadata instance
])
AT_CHECK([echo 'parser x { extract(,); }' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `,' expecting instance name
])
AT_CHECK([echo 'parser x { extract(m); }' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `m' expecting instance name
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h[[2]];
parser x { extract(h,h2); }' | ovstest test-p4 parse -], [1], [],
    [-:3: syntax error at `,' expecting `@<:@'
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h[[2]];
parser x { extract(h[[2]]); }' | ovstest test-p4 parse -], [1], [],
    [-:3: syntax error at `2' expecting integer between 0 and 1
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { extract(h[[0]]); }' | ovstest test-p4 parse -], [1], [],
    [dnl {
-:3: syntax error at `@<:@' expecting `@:}@'
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { set_metadata(h..); }' | ovstest test-p4 parse -], [1], [],
    [-:3: syntax error at `.' expecting field name
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { set_metadata(h.g); }' | ovstest test-p4 parse -], [1], [],
    [-:3: syntax error at `g' expecting field name
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { set_metadata(h.f); }' | ovstest test-p4 parse -], [1], [],
    [-:3: error: set_metadata may only be applied to metadata fields
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
metadata ht m;
parser x { set_metadata(m.f, latest.f); }' | ovstest test-p4 parse -], [1], [],
    [-:4: error: use of `latest' before `extract'
])
AT_CHECK([echo 'parser x { xyzzy; }' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `xyzzy' expecting statement
])
AT_CHECK([echo 'parser x { return select(1); }' | ovstest test-p4 parse -], [1], [],
    [-:1: error: constant value not allowed here
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { return select(h.f) { default: ingress; 1: parse_error; }' | ovstest test-p4 parse -], [1], [],
    [-:3: error: default case must be last case
])
AT_CHECK([echo 'header_type ht { fields { f: 8; } }
header ht h;
parser x { return select(h.f) { 0x100: ingress }' | ovstest test-p4 parse -], [1], [],
    [-:3: error: can't initialize 8-bit field with 9-bit constant
])
AT_CHECK([echo 'parser x { return ; }' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `;' expecting parser state name
])
AT_CLEANUP

AT_SETUP([P4 -- additional parser negative tests])
AT_CHECK([echo 'xyzzy' | ovstest test-p4 parse -], [1], [],
    [-:1: syntax error at `xyzzy' expecting top-level declaration
])
AT_CHECK([echo 'parser x { return y; }' | ovstest test-p4 parse -], [1], [],
    [-:2: error: parser state y referenced but never defined
])
AT_CLEANUP
